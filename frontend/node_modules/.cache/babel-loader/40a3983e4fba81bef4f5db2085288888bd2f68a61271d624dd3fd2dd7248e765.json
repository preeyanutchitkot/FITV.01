{"ast":null,"code":"// VideoSectionManager.js - ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ sections ‡∏Ç‡∏≠‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏ï‡∏≤‡∏° section\n\nclass VideoSectionManager {\n  constructor() {\n    // Exercise-specific body part weights\n    this.exerciseWeights = {\n      'squat': {\n        legs: 0.6,\n        // ‡πÄ‡∏ô‡πâ‡∏ô‡∏Ç‡∏≤ 60%\n        core: 0.3,\n        // ‡∏•‡∏≥‡∏ï‡∏±‡∏ß 30%\n        arms: 0.1 // ‡πÅ‡∏Ç‡∏ô 10%\n      },\n      'push-up': {\n        arms: 0.5,\n        // ‡πÄ‡∏ô‡πâ‡∏ô‡πÅ‡∏Ç‡∏ô 50%\n        core: 0.4,\n        // ‡∏•‡∏≥‡∏ï‡∏±‡∏ß 40%\n        legs: 0.1 // ‡∏Ç‡∏≤ 10%\n      },\n      'plank': {\n        core: 0.6,\n        // ‡πÄ‡∏ô‡πâ‡∏ô‡∏•‡∏≥‡∏ï‡∏±‡∏ß 60%\n        arms: 0.3,\n        // ‡πÅ‡∏Ç‡∏ô 30%\n        legs: 0.1 // ‡∏Ç‡∏≤ 10%\n      },\n      'lunge': {\n        legs: 0.7,\n        // ‡πÄ‡∏ô‡πâ‡∏ô‡∏Ç‡∏≤‡∏°‡∏≤‡∏Å 70%\n        core: 0.2,\n        // ‡∏•‡∏≥‡∏ï‡∏±‡∏ß 20%\n        arms: 0.1 // ‡πÅ‡∏Ç‡∏ô 10%\n      },\n      'burpee': {\n        legs: 0.4,\n        // ‡∏Ç‡∏≤ 40%\n        core: 0.3,\n        // ‡∏•‡∏≥‡∏ï‡∏±‡∏ß 30%\n        arms: 0.3 // ‡πÅ‡∏Ç‡∏ô 30%\n      },\n      'jumping-jack': {\n        legs: 0.5,\n        // ‡∏Ç‡∏≤ 50%\n        arms: 0.3,\n        // ‡πÅ‡∏Ç‡∏ô 30%\n        core: 0.2 // ‡∏•‡∏≥‡∏ï‡∏±‡∏ß 20%\n      },\n      'default': {\n        legs: 0.4,\n        core: 0.3,\n        arms: 0.3\n      }\n    };\n\n    // Keypoint groups for body parts\n    this.bodyPartKeypoints = {\n      legs: [23, 24, 25, 26, 27, 28, 29, 30, 31, 32],\n      // Hip, knee, ankle, foot\n      core: [11, 12, 23, 24],\n      // Shoulders and hips for core stability\n      arms: [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22] // Shoulder to fingers\n    };\n\n    // Movement detection threshold\n    this.movementThreshold = 0.02;\n    this.currentSection = null;\n    this.sectionScores = [];\n    this.frameBuffer = [];\n    this.bufferSize = 10; // Keep last 10 frames for movement detection\n  }\n\n  // Set video sections data\n  setSections(sections) {\n    this.sections = sections || [];\n    this.currentSection = null;\n    this.sectionScores = [];\n    console.log('üìπ Video sections loaded:', {\n      totalSections: this.sections.length,\n      sections: this.sections.map(s => ({\n        name: s.exercise_type,\n        start: s.start_time,\n        end: s.end_time,\n        duration: s.end_time - s.start_time\n      }))\n    });\n  }\n\n  // Get current section based on video time\n  getCurrentSection(currentTime) {\n    if (!this.sections || this.sections.length === 0) {\n      return null;\n    }\n    const section = this.sections.find(s => currentTime >= s.start_time && currentTime <= s.end_time);\n    if (section && section !== this.currentSection) {\n      this.currentSection = section;\n      console.log('üéØ Section changed:', {\n        exercise: section.exercise_type,\n        time: `${section.start_time}s - ${section.end_time}s`,\n        weights: this.getExerciseWeights(section.exercise_type)\n      });\n    }\n    return section;\n  }\n\n  // Get exercise-specific weights\n  getExerciseWeights(exerciseType) {\n    const normalizedType = (exerciseType === null || exerciseType === void 0 ? void 0 : exerciseType.toLowerCase().replace(/[_\\s-]/g, '-')) || 'default';\n    return this.exerciseWeights[normalizedType] || this.exerciseWeights.default;\n  }\n\n  // Detect if there's significant movement in keypoints\n  detectMovement(keypoints) {\n    if (!keypoints || keypoints.length === 0) return false;\n\n    // Add current frame to buffer\n    this.frameBuffer.push(keypoints);\n\n    // Keep only recent frames\n    if (this.frameBuffer.length > this.bufferSize) {\n      this.frameBuffer.shift();\n    }\n\n    // Need at least 2 frames to detect movement\n    if (this.frameBuffer.length < 2) return false;\n\n    // Calculate movement between recent frames\n    const currentFrame = this.frameBuffer[this.frameBuffer.length - 1];\n    const previousFrame = this.frameBuffer[this.frameBuffer.length - 2];\n    let totalMovement = 0;\n    let validKeypoints = 0;\n    for (let i = 0; i < Math.min(currentFrame.length, previousFrame.length); i++) {\n      const curr = currentFrame[i];\n      const prev = previousFrame[i];\n      if (curr && prev && curr.visibility > 0.5 && prev.visibility > 0.5) {\n        const dx = curr.x - prev.x;\n        const dy = curr.y - prev.y;\n        const movement = Math.sqrt(dx * dx + dy * dy);\n        totalMovement += movement;\n        validKeypoints++;\n      }\n    }\n    const averageMovement = validKeypoints > 0 ? totalMovement / validKeypoints : 0;\n    const hasMovement = averageMovement > this.movementThreshold;\n    console.log('üèÉ Movement detection:', {\n      averageMovement: averageMovement.toFixed(4),\n      threshold: this.movementThreshold,\n      hasMovement,\n      validKeypoints\n    });\n    return hasMovement;\n  }\n\n  // Calculate weighted score based on current section\n  calculateSectionScore(trainerKeypoints, traineeKeypoints, currentTime) {\n    const section = this.getCurrentSection(currentTime);\n    if (!section) {\n      console.log('‚ö†Ô∏è No section found for time:', currentTime);\n      return null;\n    }\n\n    // Check for movement\n    const hasMovement = this.detectMovement(traineeKeypoints);\n    if (!hasMovement) {\n      console.log('‚è∏Ô∏è No significant movement detected, skipping score calculation');\n      return {\n        score: null,\n        // Don't include in average\n        section: section.exercise_type,\n        reason: 'no_movement',\n        hasMovement: false\n      };\n    }\n\n    // Get exercise-specific weights\n    const weights = this.getExerciseWeights(section.exercise_type);\n    const bodyPartScores = this.calculateBodyPartScores(trainerKeypoints, traineeKeypoints);\n\n    // Calculate weighted score\n    let weightedScore = 0;\n    let totalWeight = 0;\n    for (const [bodyPart, weight] of Object.entries(weights)) {\n      if (bodyPartScores[bodyPart] !== undefined) {\n        weightedScore += bodyPartScores[bodyPart] * weight;\n        totalWeight += weight;\n      }\n    }\n    const finalScore = totalWeight > 0 ? weightedScore / totalWeight * 100 : 0;\n\n    // Store section score\n    const sectionScore = {\n      section: section.exercise_type,\n      score: finalScore,\n      time: currentTime,\n      bodyPartScores,\n      weights,\n      hasMovement: true\n    };\n    this.sectionScores.push(sectionScore);\n    console.log('üìä Section score calculated:', {\n      exercise: section.exercise_type,\n      score: finalScore.toFixed(1),\n      bodyParts: Object.entries(bodyPartScores).map(([part, score]) => `${part}: ${score.toFixed(1)}% (weight: ${(weights[part] * 100).toFixed(0)}%)`).join(', ')\n    });\n    return sectionScore;\n  }\n\n  // Calculate scores for each body part\n  calculateBodyPartScores(trainerKeypoints, traineeKeypoints) {\n    const bodyPartScores = {};\n    for (const [bodyPart, keypointIds] of Object.entries(this.bodyPartKeypoints)) {\n      let totalSimilarity = 0;\n      let validComparisons = 0;\n      for (const keypointId of keypointIds) {\n        const trainerPoint = trainerKeypoints[keypointId];\n        const traineePoint = traineeKeypoints[keypointId];\n        if (trainerPoint && traineePoint && trainerPoint.visibility > 0.5 && traineePoint.visibility > 0.5) {\n          // Calculate similarity (inverse of distance)\n          const dx = trainerPoint.x - traineePoint.x;\n          const dy = trainerPoint.y - traineePoint.y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n\n          // Convert distance to similarity score (0-1)\n          const similarity = Math.max(0, 1 - distance / 0.5); // 0.5 is max acceptable distance\n\n          totalSimilarity += similarity;\n          validComparisons++;\n        }\n      }\n\n      // Calculate average similarity for this body part\n      if (validComparisons > 0) {\n        bodyPartScores[bodyPart] = totalSimilarity / validComparisons * 100;\n      } else {\n        bodyPartScores[bodyPart] = 0;\n      }\n    }\n    return bodyPartScores;\n  }\n\n  // Get session summary with section-based analytics\n  getSessionSummary() {\n    if (this.sectionScores.length === 0) {\n      return {\n        overallScore: 0,\n        totalFrames: 0,\n        movementFrames: 0,\n        sectionBreakdown: {},\n        recommendations: ['‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏¢']\n      };\n    }\n\n    // Filter out null scores (no movement frames)\n    const validScores = this.sectionScores.filter(s => s.score !== null);\n\n    // Calculate overall average (only from movement frames)\n    const overallScore = validScores.length > 0 ? validScores.reduce((sum, s) => sum + s.score, 0) / validScores.length : 0;\n\n    // Group by section\n    const sectionBreakdown = {};\n    for (const scoreData of validScores) {\n      const section = scoreData.section;\n      if (!sectionBreakdown[section]) {\n        sectionBreakdown[section] = {\n          scores: [],\n          averageScore: 0,\n          frameCount: 0,\n          bodyPartAverages: {}\n        };\n      }\n      sectionBreakdown[section].scores.push(scoreData.score);\n      sectionBreakdown[section].frameCount++;\n\n      // Accumulate body part scores\n      for (const [bodyPart, score] of Object.entries(scoreData.bodyPartScores)) {\n        if (!sectionBreakdown[section].bodyPartAverages[bodyPart]) {\n          sectionBreakdown[section].bodyPartAverages[bodyPart] = [];\n        }\n        sectionBreakdown[section].bodyPartAverages[bodyPart].push(score);\n      }\n    }\n\n    // Calculate averages for each section\n    for (const section of Object.keys(sectionBreakdown)) {\n      const data = sectionBreakdown[section];\n      data.averageScore = data.scores.reduce((a, b) => a + b, 0) / data.scores.length;\n\n      // Average body part scores\n      for (const bodyPart of Object.keys(data.bodyPartAverages)) {\n        const scores = data.bodyPartAverages[bodyPart];\n        data.bodyPartAverages[bodyPart] = scores.reduce((a, b) => a + b, 0) / scores.length;\n      }\n    }\n\n    // Generate recommendations\n    const recommendations = this.generateRecommendations(sectionBreakdown);\n    return {\n      overallScore,\n      totalFrames: this.sectionScores.length,\n      movementFrames: validScores.length,\n      sectionBreakdown,\n      recommendations\n    };\n  }\n\n  // Generate recommendations based on section performance\n  generateRecommendations(sectionBreakdown) {\n    const recommendations = [];\n    for (const [section, data] of Object.entries(sectionBreakdown)) {\n      const avgScore = data.averageScore;\n      if (avgScore < 60) {\n        recommendations.push(`${section}: ‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏ó‡πà‡∏≤‡∏ó‡∏≤‡∏á‡πÇ‡∏î‡∏¢‡∏£‡∏ß‡∏° (${avgScore.toFixed(1)}%)`);\n\n        // Check which body part needs improvement\n        const bodyParts = Object.entries(data.bodyPartAverages).filter(([_, score]) => score < 60).map(([part]) => part);\n        if (bodyParts.length > 0) {\n          recommendations.push(`${section}: ‡πÇ‡∏ü‡∏Å‡∏±‡∏™‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á: ${bodyParts.join(', ')}`);\n        }\n      } else if (avgScore < 80) {\n        recommendations.push(`${section}: ‡∏ó‡πà‡∏≤‡∏ó‡∏≤‡∏á‡∏î‡∏µ ‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á‡πÑ‡∏î‡πâ (${avgScore.toFixed(1)}%)`);\n      } else {\n        recommendations.push(`${section}: ‡∏ó‡πà‡∏≤‡∏ó‡∏≤‡∏á‡∏î‡∏µ‡∏°‡∏≤‡∏Å! (${avgScore.toFixed(1)}%)`);\n      }\n    }\n    return recommendations;\n  }\n\n  // Reset session data\n  reset() {\n    this.currentSection = null;\n    this.sectionScores = [];\n    this.frameBuffer = [];\n  }\n}\n\n// Export singleton instance\nexport const videoSectionManager = new VideoSectionManager();","map":{"version":3,"names":["VideoSectionManager","constructor","exerciseWeights","legs","core","arms","bodyPartKeypoints","movementThreshold","currentSection","sectionScores","frameBuffer","bufferSize","setSections","sections","console","log","totalSections","length","map","s","name","exercise_type","start","start_time","end","end_time","duration","getCurrentSection","currentTime","section","find","exercise","time","weights","getExerciseWeights","exerciseType","normalizedType","toLowerCase","replace","default","detectMovement","keypoints","push","shift","currentFrame","previousFrame","totalMovement","validKeypoints","i","Math","min","curr","prev","visibility","dx","x","dy","y","movement","sqrt","averageMovement","hasMovement","toFixed","threshold","calculateSectionScore","trainerKeypoints","traineeKeypoints","score","reason","bodyPartScores","calculateBodyPartScores","weightedScore","totalWeight","bodyPart","weight","Object","entries","undefined","finalScore","sectionScore","bodyParts","part","join","keypointIds","totalSimilarity","validComparisons","keypointId","trainerPoint","traineePoint","distance","similarity","max","getSessionSummary","overallScore","totalFrames","movementFrames","sectionBreakdown","recommendations","validScores","filter","reduce","sum","scoreData","scores","averageScore","frameCount","bodyPartAverages","keys","data","a","b","generateRecommendations","avgScore","_","reset","videoSectionManager"],"sources":["E:/BackupFit/frontend/src/utils/VideoSectionManager.js"],"sourcesContent":["// VideoSectionManager.js - ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ sections ‡∏Ç‡∏≠‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏ï‡∏≤‡∏° section\r\n\r\nclass VideoSectionManager {\r\n  constructor() {\r\n    // Exercise-specific body part weights\r\n    this.exerciseWeights = {\r\n      'squat': {\r\n        legs: 0.6,      // ‡πÄ‡∏ô‡πâ‡∏ô‡∏Ç‡∏≤ 60%\r\n        core: 0.3,      // ‡∏•‡∏≥‡∏ï‡∏±‡∏ß 30%\r\n        arms: 0.1       // ‡πÅ‡∏Ç‡∏ô 10%\r\n      },\r\n      'push-up': {\r\n        arms: 0.5,      // ‡πÄ‡∏ô‡πâ‡∏ô‡πÅ‡∏Ç‡∏ô 50%\r\n        core: 0.4,      // ‡∏•‡∏≥‡∏ï‡∏±‡∏ß 40%\r\n        legs: 0.1       // ‡∏Ç‡∏≤ 10%\r\n      },\r\n      'plank': {\r\n        core: 0.6,      // ‡πÄ‡∏ô‡πâ‡∏ô‡∏•‡∏≥‡∏ï‡∏±‡∏ß 60%\r\n        arms: 0.3,      // ‡πÅ‡∏Ç‡∏ô 30%\r\n        legs: 0.1       // ‡∏Ç‡∏≤ 10%\r\n      },\r\n      'lunge': {\r\n        legs: 0.7,      // ‡πÄ‡∏ô‡πâ‡∏ô‡∏Ç‡∏≤‡∏°‡∏≤‡∏Å 70%\r\n        core: 0.2,      // ‡∏•‡∏≥‡∏ï‡∏±‡∏ß 20%\r\n        arms: 0.1       // ‡πÅ‡∏Ç‡∏ô 10%\r\n      },\r\n      'burpee': {\r\n        legs: 0.4,      // ‡∏Ç‡∏≤ 40%\r\n        core: 0.3,      // ‡∏•‡∏≥‡∏ï‡∏±‡∏ß 30%\r\n        arms: 0.3       // ‡πÅ‡∏Ç‡∏ô 30%\r\n      },\r\n      'jumping-jack': {\r\n        legs: 0.5,      // ‡∏Ç‡∏≤ 50%\r\n        arms: 0.3,      // ‡πÅ‡∏Ç‡∏ô 30%\r\n        core: 0.2       // ‡∏•‡∏≥‡∏ï‡∏±‡∏ß 20%\r\n      },\r\n      'default': {\r\n        legs: 0.4,\r\n        core: 0.3,\r\n        arms: 0.3\r\n      }\r\n    };\r\n\r\n    // Keypoint groups for body parts\r\n    this.bodyPartKeypoints = {\r\n      legs: [23, 24, 25, 26, 27, 28, 29, 30, 31, 32], // Hip, knee, ankle, foot\r\n      core: [11, 12, 23, 24], // Shoulders and hips for core stability\r\n      arms: [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22] // Shoulder to fingers\r\n    };\r\n\r\n    // Movement detection threshold\r\n    this.movementThreshold = 0.02;\r\n    this.currentSection = null;\r\n    this.sectionScores = [];\r\n    this.frameBuffer = [];\r\n    this.bufferSize = 10; // Keep last 10 frames for movement detection\r\n  }\r\n\r\n  // Set video sections data\r\n  setSections(sections) {\r\n    this.sections = sections || [];\r\n    this.currentSection = null;\r\n    this.sectionScores = [];\r\n    \r\n    console.log('üìπ Video sections loaded:', {\r\n      totalSections: this.sections.length,\r\n      sections: this.sections.map(s => ({\r\n        name: s.exercise_type,\r\n        start: s.start_time,\r\n        end: s.end_time,\r\n        duration: s.end_time - s.start_time\r\n      }))\r\n    });\r\n  }\r\n\r\n  // Get current section based on video time\r\n  getCurrentSection(currentTime) {\r\n    if (!this.sections || this.sections.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const section = this.sections.find(s => \r\n      currentTime >= s.start_time && currentTime <= s.end_time\r\n    );\r\n\r\n    if (section && section !== this.currentSection) {\r\n      this.currentSection = section;\r\n      console.log('üéØ Section changed:', {\r\n        exercise: section.exercise_type,\r\n        time: `${section.start_time}s - ${section.end_time}s`,\r\n        weights: this.getExerciseWeights(section.exercise_type)\r\n      });\r\n    }\r\n\r\n    return section;\r\n  }\r\n\r\n  // Get exercise-specific weights\r\n  getExerciseWeights(exerciseType) {\r\n    const normalizedType = exerciseType?.toLowerCase().replace(/[_\\s-]/g, '-') || 'default';\r\n    return this.exerciseWeights[normalizedType] || this.exerciseWeights.default;\r\n  }\r\n\r\n  // Detect if there's significant movement in keypoints\r\n  detectMovement(keypoints) {\r\n    if (!keypoints || keypoints.length === 0) return false;\r\n\r\n    // Add current frame to buffer\r\n    this.frameBuffer.push(keypoints);\r\n    \r\n    // Keep only recent frames\r\n    if (this.frameBuffer.length > this.bufferSize) {\r\n      this.frameBuffer.shift();\r\n    }\r\n\r\n    // Need at least 2 frames to detect movement\r\n    if (this.frameBuffer.length < 2) return false;\r\n\r\n    // Calculate movement between recent frames\r\n    const currentFrame = this.frameBuffer[this.frameBuffer.length - 1];\r\n    const previousFrame = this.frameBuffer[this.frameBuffer.length - 2];\r\n\r\n    let totalMovement = 0;\r\n    let validKeypoints = 0;\r\n\r\n    for (let i = 0; i < Math.min(currentFrame.length, previousFrame.length); i++) {\r\n      const curr = currentFrame[i];\r\n      const prev = previousFrame[i];\r\n      \r\n      if (curr && prev && curr.visibility > 0.5 && prev.visibility > 0.5) {\r\n        const dx = curr.x - prev.x;\r\n        const dy = curr.y - prev.y;\r\n        const movement = Math.sqrt(dx * dx + dy * dy);\r\n        \r\n        totalMovement += movement;\r\n        validKeypoints++;\r\n      }\r\n    }\r\n\r\n    const averageMovement = validKeypoints > 0 ? totalMovement / validKeypoints : 0;\r\n    const hasMovement = averageMovement > this.movementThreshold;\r\n\r\n    console.log('üèÉ Movement detection:', {\r\n      averageMovement: averageMovement.toFixed(4),\r\n      threshold: this.movementThreshold,\r\n      hasMovement,\r\n      validKeypoints\r\n    });\r\n\r\n    return hasMovement;\r\n  }\r\n\r\n  // Calculate weighted score based on current section\r\n  calculateSectionScore(trainerKeypoints, traineeKeypoints, currentTime) {\r\n    const section = this.getCurrentSection(currentTime);\r\n    \r\n    if (!section) {\r\n      console.log('‚ö†Ô∏è No section found for time:', currentTime);\r\n      return null;\r\n    }\r\n\r\n    // Check for movement\r\n    const hasMovement = this.detectMovement(traineeKeypoints);\r\n    \r\n    if (!hasMovement) {\r\n      console.log('‚è∏Ô∏è No significant movement detected, skipping score calculation');\r\n      return {\r\n        score: null, // Don't include in average\r\n        section: section.exercise_type,\r\n        reason: 'no_movement',\r\n        hasMovement: false\r\n      };\r\n    }\r\n\r\n    // Get exercise-specific weights\r\n    const weights = this.getExerciseWeights(section.exercise_type);\r\n    const bodyPartScores = this.calculateBodyPartScores(trainerKeypoints, traineeKeypoints);\r\n    \r\n    // Calculate weighted score\r\n    let weightedScore = 0;\r\n    let totalWeight = 0;\r\n\r\n    for (const [bodyPart, weight] of Object.entries(weights)) {\r\n      if (bodyPartScores[bodyPart] !== undefined) {\r\n        weightedScore += bodyPartScores[bodyPart] * weight;\r\n        totalWeight += weight;\r\n      }\r\n    }\r\n\r\n    const finalScore = totalWeight > 0 ? (weightedScore / totalWeight) * 100 : 0;\r\n\r\n    // Store section score\r\n    const sectionScore = {\r\n      section: section.exercise_type,\r\n      score: finalScore,\r\n      time: currentTime,\r\n      bodyPartScores,\r\n      weights,\r\n      hasMovement: true\r\n    };\r\n\r\n    this.sectionScores.push(sectionScore);\r\n\r\n    console.log('üìä Section score calculated:', {\r\n      exercise: section.exercise_type,\r\n      score: finalScore.toFixed(1),\r\n      bodyParts: Object.entries(bodyPartScores).map(([part, score]) => \r\n        `${part}: ${score.toFixed(1)}% (weight: ${(weights[part] * 100).toFixed(0)}%)`\r\n      ).join(', ')\r\n    });\r\n\r\n    return sectionScore;\r\n  }\r\n\r\n  // Calculate scores for each body part\r\n  calculateBodyPartScores(trainerKeypoints, traineeKeypoints) {\r\n    const bodyPartScores = {};\r\n\r\n    for (const [bodyPart, keypointIds] of Object.entries(this.bodyPartKeypoints)) {\r\n      let totalSimilarity = 0;\r\n      let validComparisons = 0;\r\n\r\n      for (const keypointId of keypointIds) {\r\n        const trainerPoint = trainerKeypoints[keypointId];\r\n        const traineePoint = traineeKeypoints[keypointId];\r\n\r\n        if (trainerPoint && traineePoint && \r\n            trainerPoint.visibility > 0.5 && traineePoint.visibility > 0.5) {\r\n          \r\n          // Calculate similarity (inverse of distance)\r\n          const dx = trainerPoint.x - traineePoint.x;\r\n          const dy = trainerPoint.y - traineePoint.y;\r\n          const distance = Math.sqrt(dx * dx + dy * dy);\r\n          \r\n          // Convert distance to similarity score (0-1)\r\n          const similarity = Math.max(0, 1 - (distance / 0.5)); // 0.5 is max acceptable distance\r\n          \r\n          totalSimilarity += similarity;\r\n          validComparisons++;\r\n        }\r\n      }\r\n\r\n      // Calculate average similarity for this body part\r\n      if (validComparisons > 0) {\r\n        bodyPartScores[bodyPart] = (totalSimilarity / validComparisons) * 100;\r\n      } else {\r\n        bodyPartScores[bodyPart] = 0;\r\n      }\r\n    }\r\n\r\n    return bodyPartScores;\r\n  }\r\n\r\n  // Get session summary with section-based analytics\r\n  getSessionSummary() {\r\n    if (this.sectionScores.length === 0) {\r\n      return {\r\n        overallScore: 0,\r\n        totalFrames: 0,\r\n        movementFrames: 0,\r\n        sectionBreakdown: {},\r\n        recommendations: ['‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏¢']\r\n      };\r\n    }\r\n\r\n    // Filter out null scores (no movement frames)\r\n    const validScores = this.sectionScores.filter(s => s.score !== null);\r\n    \r\n    // Calculate overall average (only from movement frames)\r\n    const overallScore = validScores.length > 0 \r\n      ? validScores.reduce((sum, s) => sum + s.score, 0) / validScores.length \r\n      : 0;\r\n\r\n    // Group by section\r\n    const sectionBreakdown = {};\r\n    for (const scoreData of validScores) {\r\n      const section = scoreData.section;\r\n      if (!sectionBreakdown[section]) {\r\n        sectionBreakdown[section] = {\r\n          scores: [],\r\n          averageScore: 0,\r\n          frameCount: 0,\r\n          bodyPartAverages: {}\r\n        };\r\n      }\r\n      \r\n      sectionBreakdown[section].scores.push(scoreData.score);\r\n      sectionBreakdown[section].frameCount++;\r\n      \r\n      // Accumulate body part scores\r\n      for (const [bodyPart, score] of Object.entries(scoreData.bodyPartScores)) {\r\n        if (!sectionBreakdown[section].bodyPartAverages[bodyPart]) {\r\n          sectionBreakdown[section].bodyPartAverages[bodyPart] = [];\r\n        }\r\n        sectionBreakdown[section].bodyPartAverages[bodyPart].push(score);\r\n      }\r\n    }\r\n\r\n    // Calculate averages for each section\r\n    for (const section of Object.keys(sectionBreakdown)) {\r\n      const data = sectionBreakdown[section];\r\n      data.averageScore = data.scores.reduce((a, b) => a + b, 0) / data.scores.length;\r\n      \r\n      // Average body part scores\r\n      for (const bodyPart of Object.keys(data.bodyPartAverages)) {\r\n        const scores = data.bodyPartAverages[bodyPart];\r\n        data.bodyPartAverages[bodyPart] = scores.reduce((a, b) => a + b, 0) / scores.length;\r\n      }\r\n    }\r\n\r\n    // Generate recommendations\r\n    const recommendations = this.generateRecommendations(sectionBreakdown);\r\n\r\n    return {\r\n      overallScore,\r\n      totalFrames: this.sectionScores.length,\r\n      movementFrames: validScores.length,\r\n      sectionBreakdown,\r\n      recommendations\r\n    };\r\n  }\r\n\r\n  // Generate recommendations based on section performance\r\n  generateRecommendations(sectionBreakdown) {\r\n    const recommendations = [];\r\n\r\n    for (const [section, data] of Object.entries(sectionBreakdown)) {\r\n      const avgScore = data.averageScore;\r\n      \r\n      if (avgScore < 60) {\r\n        recommendations.push(`${section}: ‡∏ï‡πâ‡∏≠‡∏á‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏ó‡πà‡∏≤‡∏ó‡∏≤‡∏á‡πÇ‡∏î‡∏¢‡∏£‡∏ß‡∏° (${avgScore.toFixed(1)}%)`);\r\n        \r\n        // Check which body part needs improvement\r\n        const bodyParts = Object.entries(data.bodyPartAverages)\r\n          .filter(([_, score]) => score < 60)\r\n          .map(([part]) => part);\r\n        \r\n        if (bodyParts.length > 0) {\r\n          recommendations.push(`${section}: ‡πÇ‡∏ü‡∏Å‡∏±‡∏™‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á: ${bodyParts.join(', ')}`);\r\n        }\r\n      } else if (avgScore < 80) {\r\n        recommendations.push(`${section}: ‡∏ó‡πà‡∏≤‡∏ó‡∏≤‡∏á‡∏î‡∏µ ‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á‡πÑ‡∏î‡πâ (${avgScore.toFixed(1)}%)`);\r\n      } else {\r\n        recommendations.push(`${section}: ‡∏ó‡πà‡∏≤‡∏ó‡∏≤‡∏á‡∏î‡∏µ‡∏°‡∏≤‡∏Å! (${avgScore.toFixed(1)}%)`);\r\n      }\r\n    }\r\n\r\n    return recommendations;\r\n  }\r\n\r\n  // Reset session data\r\n  reset() {\r\n    this.currentSection = null;\r\n    this.sectionScores = [];\r\n    this.frameBuffer = [];\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const videoSectionManager = new VideoSectionManager();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}