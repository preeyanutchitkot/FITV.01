{"ast":null,"code":"// VideoSegmentService.js - Service ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ video segments\n\nclass VideoSegmentService {\n  constructor(baseURL = 'http://localhost:8000') {\n    this.baseURL = baseURL;\n  }\n\n  // ‡∏™‡∏£‡πâ‡∏≤‡∏á segment ‡πÉ‡∏´‡∏°‡πà (‡∏à‡∏∞ trigger keypoints extraction ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥)\n  async createSegment(videoId, segmentData) {\n    try {\n      const token = localStorage.getItem(\"token\");\n      const response = await fetch(`${this.baseURL}/videos/${videoId}/segments`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${token}`\n        },\n        body: JSON.stringify({\n          exercise_id: segmentData.exerciseId,\n          start_time: segmentData.startTime,\n          end_time: segmentData.endTime\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.detail || `HTTP ${response.status}`);\n      }\n      const result = await response.json();\n      console.log('‚úÖ Segment created successfully:', result);\n      return result;\n    } catch (error) {\n      console.error('‚ùå Error creating segment:', error);\n      throw error;\n    }\n  }\n\n  // ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ segments ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á video\n  async getVideoSegments(videoId) {\n    try {\n      const response = await fetch(`${this.baseURL}/videos/${videoId}/segments`);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error getting video segments:', error);\n      throw error;\n    }\n  }\n\n  // ‡∏•‡∏ö segment\n  async deleteSegment(videoId, segmentId) {\n    try {\n      const token = localStorage.getItem(\"token\");\n      const response = await fetch(`${this.baseURL}/videos/${videoId}/segments/${segmentId}`, {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bearer ${token}`\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error deleting segment:', error);\n      throw error;\n    }\n  }\n\n  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ keypoints ‡∏Ç‡∏≠‡∏á segment\n  async getKeypointsStatus(videoId, segmentId) {\n    try {\n      const response = await fetch(`${this.baseURL}/videos/${videoId}/segments/${segmentId}/keypoints/status`);\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error getting keypoints status:', error);\n      throw error;\n    }\n  }\n\n  // Poll ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ keypoints ‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏™‡∏£‡πá‡∏à\n  async waitForKeypointsCompletion(videoId, segmentId, onProgress = null, maxAttempts = 30) {\n    let attempts = 0;\n    while (attempts < maxAttempts) {\n      try {\n        const status = await this.getKeypointsStatus(videoId, segmentId);\n        if (onProgress) {\n          onProgress({\n            segmentId: segmentId,\n            hasKeypoints: status.has_keypoints,\n            processing: status.processing,\n            framesCount: status.frames_count,\n            attempt: attempts + 1,\n            maxAttempts: maxAttempts\n          });\n        }\n\n        // ‡∏ñ‡πâ‡∏≤‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß\n        if (status.has_keypoints && !status.processing) {\n          console.log(`‚úÖ Keypoints ready for segment ${segmentId}`);\n          return status;\n        }\n\n        // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏™‡∏£‡πá‡∏à ‡∏£‡∏≠ 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà\n        await new Promise(resolve => setTimeout(resolve, 2000));\n        attempts++;\n      } catch (error) {\n        console.error(`Error checking keypoints status (attempt ${attempts + 1}):`, error);\n        attempts++;\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      }\n    }\n    throw new Error(`Keypoints processing timeout for segment ${segmentId}`);\n  }\n\n  // ‡∏™‡∏£‡πâ‡∏≤‡∏á segment ‡πÅ‡∏•‡∏∞‡∏£‡∏≠‡πÉ‡∏´‡πâ keypoints ‡πÄ‡∏™‡∏£‡πá‡∏à\n  async createSegmentWithKeypoints(videoId, segmentData, onProgress = null) {\n    try {\n      // 1. ‡∏™‡∏£‡πâ‡∏≤‡∏á segment\n      console.log(`üöÄ Creating segment for exercise ${segmentData.exerciseId}...`);\n      const segment = await this.createSegment(videoId, segmentData);\n      if (onProgress) {\n        onProgress({\n          phase: 'created',\n          segmentId: segment.id,\n          message: `Segment created, starting keypoints extraction...`\n        });\n      }\n\n      // 2. ‡∏£‡∏≠‡πÉ‡∏´‡πâ keypoints ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à\n      console.log(`‚è≥ Waiting for keypoints extraction...`);\n      const finalStatus = await this.waitForKeypointsCompletion(videoId, segment.id, status => {\n        if (onProgress) {\n          onProgress({\n            phase: 'processing',\n            segmentId: segment.id,\n            message: `Processing keypoints... (${status.attempt}/${status.maxAttempts})`,\n            hasKeypoints: status.hasKeypoints,\n            framesCount: status.framesCount\n          });\n        }\n      });\n      if (onProgress) {\n        onProgress({\n          phase: 'completed',\n          segmentId: segment.id,\n          message: `Keypoints extraction completed! (${finalStatus.frames_count} frames)`,\n          hasKeypoints: true,\n          framesCount: finalStatus.frames_count\n        });\n      }\n      return {\n        segment: segment,\n        keypoints_status: finalStatus\n      };\n    } catch (error) {\n      if (onProgress) {\n        onProgress({\n          phase: 'error',\n          message: `Error: ${error.message}`,\n          error: true\n        });\n      }\n      throw error;\n    }\n  }\n\n  // Batch create segments (‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏•‡∏≤‡∏¢ segments ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô)\n  async createMultipleSegments(videoId, segmentsData, onProgress = null) {\n    const results = [];\n    let completedCount = 0;\n    for (const segmentData of segmentsData) {\n      try {\n        const result = await this.createSegmentWithKeypoints(videoId, segmentData, progress => {\n          if (onProgress) {\n            onProgress({\n              total: segmentsData.length,\n              completed: completedCount,\n              current: progress,\n              overall_progress: completedCount / segmentsData.length * 100\n            });\n          }\n        });\n        results.push({\n          success: true,\n          segmentData: segmentData,\n          result: result\n        });\n        completedCount++;\n      } catch (error) {\n        console.error(`‚ùå Failed to create segment:`, error);\n        results.push({\n          success: false,\n          segmentData: segmentData,\n          error: error.message\n        });\n      }\n    }\n    return {\n      total: segmentsData.length,\n      successful: results.filter(r => r.success).length,\n      failed: results.filter(r => !r.success).length,\n      results: results\n    };\n  }\n}\nexport default VideoSegmentService;","map":{"version":3,"names":["VideoSegmentService","constructor","baseURL","createSegment","videoId","segmentData","token","localStorage","getItem","response","fetch","method","headers","body","JSON","stringify","exercise_id","exerciseId","start_time","startTime","end_time","endTime","ok","errorData","json","catch","Error","detail","status","result","console","log","error","getVideoSegments","deleteSegment","segmentId","getKeypointsStatus","waitForKeypointsCompletion","onProgress","maxAttempts","attempts","hasKeypoints","has_keypoints","processing","framesCount","frames_count","attempt","Promise","resolve","setTimeout","createSegmentWithKeypoints","segment","phase","id","message","finalStatus","keypoints_status","createMultipleSegments","segmentsData","results","completedCount","progress","total","length","completed","current","overall_progress","push","success","successful","filter","r","failed"],"sources":["C:/Fitaddict‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î/Fit/frontend/src/services/VideoSegmentService.js"],"sourcesContent":["// VideoSegmentService.js - Service ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ video segments\r\n\r\nclass VideoSegmentService {\r\n    constructor(baseURL = 'http://localhost:8000') {\r\n        this.baseURL = baseURL;\r\n    }\r\n\r\n    // ‡∏™‡∏£‡πâ‡∏≤‡∏á segment ‡πÉ‡∏´‡∏°‡πà (‡∏à‡∏∞ trigger keypoints extraction ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥)\r\n    async createSegment(videoId, segmentData) {\r\n        try {\r\n            const token = localStorage.getItem(\"token\");\r\n            const response = await fetch(\r\n                `${this.baseURL}/videos/${videoId}/segments`,\r\n                {\r\n                    method: 'POST',\r\n                    headers: {\r\n                        'Content-Type': 'application/json',\r\n                        'Authorization': `Bearer ${token}`\r\n                    },\r\n                    body: JSON.stringify({\r\n                        exercise_id: segmentData.exerciseId,\r\n                        start_time: segmentData.startTime,\r\n                        end_time: segmentData.endTime\r\n                    })\r\n                }\r\n            );\r\n\r\n            if (!response.ok) {\r\n                const errorData = await response.json().catch(() => ({}));\r\n                throw new Error(errorData.detail || `HTTP ${response.status}`);\r\n            }\r\n\r\n            const result = await response.json();\r\n            console.log('‚úÖ Segment created successfully:', result);\r\n            return result;\r\n\r\n        } catch (error) {\r\n            console.error('‚ùå Error creating segment:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ segments ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á video\r\n    async getVideoSegments(videoId) {\r\n        try {\r\n            const response = await fetch(\r\n                `${this.baseURL}/videos/${videoId}/segments`\r\n            );\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`HTTP ${response.status}`);\r\n            }\r\n\r\n            return await response.json();\r\n\r\n        } catch (error) {\r\n            console.error('Error getting video segments:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // ‡∏•‡∏ö segment\r\n    async deleteSegment(videoId, segmentId) {\r\n        try {\r\n            const token = localStorage.getItem(\"token\");\r\n            const response = await fetch(\r\n                `${this.baseURL}/videos/${videoId}/segments/${segmentId}`,\r\n                {\r\n                    method: 'DELETE',\r\n                    headers: {\r\n                        'Authorization': `Bearer ${token}`\r\n                    }\r\n                }\r\n            );\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`HTTP ${response.status}`);\r\n            }\r\n\r\n            return await response.json();\r\n\r\n        } catch (error) {\r\n            console.error('Error deleting segment:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ keypoints ‡∏Ç‡∏≠‡∏á segment\r\n    async getKeypointsStatus(videoId, segmentId) {\r\n        try {\r\n            const response = await fetch(\r\n                `${this.baseURL}/videos/${videoId}/segments/${segmentId}/keypoints/status`\r\n            );\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`HTTP ${response.status}`);\r\n            }\r\n\r\n            return await response.json();\r\n\r\n        } catch (error) {\r\n            console.error('Error getting keypoints status:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Poll ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ keypoints ‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏™‡∏£‡πá‡∏à\r\n    async waitForKeypointsCompletion(videoId, segmentId, onProgress = null, maxAttempts = 30) {\r\n        let attempts = 0;\r\n        \r\n        while (attempts < maxAttempts) {\r\n            try {\r\n                const status = await this.getKeypointsStatus(videoId, segmentId);\r\n                \r\n                if (onProgress) {\r\n                    onProgress({\r\n                        segmentId: segmentId,\r\n                        hasKeypoints: status.has_keypoints,\r\n                        processing: status.processing,\r\n                        framesCount: status.frames_count,\r\n                        attempt: attempts + 1,\r\n                        maxAttempts: maxAttempts\r\n                    });\r\n                }\r\n\r\n                // ‡∏ñ‡πâ‡∏≤‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß\r\n                if (status.has_keypoints && !status.processing) {\r\n                    console.log(`‚úÖ Keypoints ready for segment ${segmentId}`);\r\n                    return status;\r\n                }\r\n\r\n                // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏™‡∏£‡πá‡∏à ‡∏£‡∏≠ 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà\r\n                await new Promise(resolve => setTimeout(resolve, 2000));\r\n                attempts++;\r\n\r\n            } catch (error) {\r\n                console.error(`Error checking keypoints status (attempt ${attempts + 1}):`, error);\r\n                attempts++;\r\n                await new Promise(resolve => setTimeout(resolve, 2000));\r\n            }\r\n        }\r\n\r\n        throw new Error(`Keypoints processing timeout for segment ${segmentId}`);\r\n    }\r\n\r\n    // ‡∏™‡∏£‡πâ‡∏≤‡∏á segment ‡πÅ‡∏•‡∏∞‡∏£‡∏≠‡πÉ‡∏´‡πâ keypoints ‡πÄ‡∏™‡∏£‡πá‡∏à\r\n    async createSegmentWithKeypoints(videoId, segmentData, onProgress = null) {\r\n        try {\r\n            // 1. ‡∏™‡∏£‡πâ‡∏≤‡∏á segment\r\n            console.log(`üöÄ Creating segment for exercise ${segmentData.exerciseId}...`);\r\n            const segment = await this.createSegment(videoId, segmentData);\r\n\r\n            if (onProgress) {\r\n                onProgress({\r\n                    phase: 'created',\r\n                    segmentId: segment.id,\r\n                    message: `Segment created, starting keypoints extraction...`\r\n                });\r\n            }\r\n\r\n            // 2. ‡∏£‡∏≠‡πÉ‡∏´‡πâ keypoints ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à\r\n            console.log(`‚è≥ Waiting for keypoints extraction...`);\r\n            const finalStatus = await this.waitForKeypointsCompletion(\r\n                videoId, \r\n                segment.id, \r\n                (status) => {\r\n                    if (onProgress) {\r\n                        onProgress({\r\n                            phase: 'processing',\r\n                            segmentId: segment.id,\r\n                            message: `Processing keypoints... (${status.attempt}/${status.maxAttempts})`,\r\n                            hasKeypoints: status.hasKeypoints,\r\n                            framesCount: status.framesCount\r\n                        });\r\n                    }\r\n                }\r\n            );\r\n\r\n            if (onProgress) {\r\n                onProgress({\r\n                    phase: 'completed',\r\n                    segmentId: segment.id,\r\n                    message: `Keypoints extraction completed! (${finalStatus.frames_count} frames)`,\r\n                    hasKeypoints: true,\r\n                    framesCount: finalStatus.frames_count\r\n                });\r\n            }\r\n\r\n            return {\r\n                segment: segment,\r\n                keypoints_status: finalStatus\r\n            };\r\n\r\n        } catch (error) {\r\n            if (onProgress) {\r\n                onProgress({\r\n                    phase: 'error',\r\n                    message: `Error: ${error.message}`,\r\n                    error: true\r\n                });\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    // Batch create segments (‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏•‡∏≤‡∏¢ segments ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô)\r\n    async createMultipleSegments(videoId, segmentsData, onProgress = null) {\r\n        const results = [];\r\n        let completedCount = 0;\r\n\r\n        for (const segmentData of segmentsData) {\r\n            try {\r\n                const result = await this.createSegmentWithKeypoints(\r\n                    videoId, \r\n                    segmentData, \r\n                    (progress) => {\r\n                        if (onProgress) {\r\n                            onProgress({\r\n                                total: segmentsData.length,\r\n                                completed: completedCount,\r\n                                current: progress,\r\n                                overall_progress: (completedCount / segmentsData.length) * 100\r\n                            });\r\n                        }\r\n                    }\r\n                );\r\n\r\n                results.push({\r\n                    success: true,\r\n                    segmentData: segmentData,\r\n                    result: result\r\n                });\r\n\r\n                completedCount++;\r\n\r\n            } catch (error) {\r\n                console.error(`‚ùå Failed to create segment:`, error);\r\n                results.push({\r\n                    success: false,\r\n                    segmentData: segmentData,\r\n                    error: error.message\r\n                });\r\n            }\r\n        }\r\n\r\n        return {\r\n            total: segmentsData.length,\r\n            successful: results.filter(r => r.success).length,\r\n            failed: results.filter(r => !r.success).length,\r\n            results: results\r\n        };\r\n    }\r\n}\r\n\r\nexport default VideoSegmentService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}