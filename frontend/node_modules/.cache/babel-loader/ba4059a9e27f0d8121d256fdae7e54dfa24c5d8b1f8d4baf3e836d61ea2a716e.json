{"ast":null,"code":"var _jsxFileName = \"C:\\\\Fit\\\\frontend\\\\src\\\\components\\\\KeypointOverlay.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst KeypointOverlay = ({\n  videoRef,\n  isPlaying,\n  onKeypointsDetected\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [pose, setPose] = useState(null);\n\n  // MediaPipe Pose connections (33 landmarks)\n  const POSE_CONNECTIONS = [\n  // Face\n  [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8],\n  // Arms\n  [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19], [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20],\n  // Body\n  [11, 23], [12, 24], [23, 24],\n  // Legs\n  [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]];\n  useEffect(() => {\n    const initializeMediaPipe = async () => {\n      try {\n        // โหลด MediaPipe จาก CDN\n        if (!window.Pose) {\n          // โหลด scripts จาก CDN\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js');\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js');\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js');\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js');\n        }\n        const poseInstance = new window.Pose({\n          locateFile: file => {\n            return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\n          }\n        });\n        poseInstance.setOptions({\n          modelComplexity: 1,\n          smoothLandmarks: true,\n          enableSegmentation: false,\n          smoothSegmentation: true,\n          minDetectionConfidence: 0.5,\n          minTrackingConfidence: 0.5\n        });\n        poseInstance.onResults(onResults);\n        setPose(poseInstance);\n        setIsInitialized(true);\n      } catch (error) {\n        console.error('Failed to load MediaPipe:', error);\n      }\n    };\n    initializeMediaPipe();\n  }, []);\n\n  // Helper function to load scripts\n  const loadScript = src => {\n    return new Promise((resolve, reject) => {\n      if (document.querySelector(`script[src=\"${src}\"]`)) {\n        resolve();\n        return;\n      }\n      const script = document.createElement('script');\n      script.src = src;\n      script.onload = resolve;\n      script.onerror = reject;\n      document.head.appendChild(script);\n    });\n  };\n  useEffect(() => {\n    if (!isInitialized || !poseNet || !(videoRef !== null && videoRef !== void 0 && videoRef.current) || !canvasRef.current) return;\n    const video = videoRef.current;\n    const canvas = canvasRef.current;\n    const processFrame = async () => {\n      if (video.paused || video.ended || !isPlaying) return;\n      try {\n        // Match canvas size to video display size\n        const rect = video.getBoundingClientRect();\n        canvas.width = rect.width;\n        canvas.height = rect.height;\n\n        // Estimate pose\n        const pose = await poseNet.estimateSinglePose(video, {\n          flipHorizontal: false\n        });\n        if (pose && pose.score > 0.3) {\n          drawPose(pose, canvas, video);\n          if (onKeypointsDetected) {\n            onKeypointsDetected(pose.keypoints);\n          }\n        }\n      } catch (error) {\n        console.error('Pose detection error:', error);\n      }\n      if (isPlaying && !video.paused && !video.ended) {\n        requestAnimationFrame(processFrame);\n      }\n    };\n    if (isPlaying) {\n      if (video.readyState >= 2) {\n        processFrame();\n      } else {\n        video.addEventListener('loadeddata', processFrame, {\n          once: true\n        });\n      }\n    }\n\n    // Clean up canvas when not playing\n    if (!isPlaying) {\n      const ctx = canvas.getContext('2d');\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n  }, [isPlaying, isInitialized, poseNet]);\n  const drawPose = (pose, canvas, video) => {\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Calculate proper scaling to match video display\n    const videoRect = video.getBoundingClientRect();\n    const videoAspect = video.videoWidth / video.videoHeight;\n    const displayAspect = videoRect.width / videoRect.height;\n    let scaleX,\n      scaleY,\n      offsetX = 0,\n      offsetY = 0;\n    if (videoAspect > displayAspect) {\n      // Video is wider - fit by width\n      scaleX = videoRect.width / video.videoWidth;\n      scaleY = scaleX;\n      offsetY = (videoRect.height - video.videoHeight * scaleY) / 2;\n    } else {\n      // Video is taller - fit by height\n      scaleY = videoRect.height / video.videoHeight;\n      scaleX = scaleY;\n      offsetX = (videoRect.width - video.videoWidth * scaleX) / 2;\n    }\n\n    // Draw skeleton connections with normalized coordinates\n    POSE_CONNECTIONS.forEach(([i, j]) => {\n      const kp1 = pose.keypoints[i];\n      const kp2 = pose.keypoints[j];\n      if (kp1.score > 0.3 && kp2.score > 0.3) {\n        ctx.beginPath();\n        ctx.moveTo(kp1.position.x * scaleX + offsetX, kp1.position.y * scaleY + offsetY);\n        ctx.lineTo(kp2.position.x * scaleX + offsetX, kp2.position.y * scaleY + offsetY);\n        ctx.strokeStyle = '#00FF00';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n      }\n    });\n\n    // Draw keypoints with normalized coordinates\n    pose.keypoints.forEach((keypoint, index) => {\n      if (keypoint.score > 0.3) {\n        ctx.beginPath();\n        ctx.arc(keypoint.position.x * scaleX + offsetX, keypoint.position.y * scaleY + offsetY, 3, 0, 2 * Math.PI);\n\n        // Different colors for different body parts\n        if (index <= 4) ctx.fillStyle = '#FF6B6B'; // Head\n        else if (index <= 10) ctx.fillStyle = '#4ECDC4'; // Arms  \n        else ctx.fillStyle = '#45B7D1'; // Body & Legs\n\n        ctx.fill();\n      }\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      zIndex: 10\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 192,\n    columnNumber: 5\n  }, this);\n};\n_s(KeypointOverlay, \"kd/K2FxSuMiBeGgIk3onvWwqU4w=\");\n_c = KeypointOverlay;\nexport default KeypointOverlay;\nvar _c;\n$RefreshReg$(_c, \"KeypointOverlay\");","map":{"version":3,"names":["React","useRef","useEffect","useState","jsxDEV","_jsxDEV","KeypointOverlay","videoRef","isPlaying","onKeypointsDetected","_s","canvasRef","isInitialized","setIsInitialized","pose","setPose","POSE_CONNECTIONS","initializeMediaPipe","window","Pose","loadScript","poseInstance","locateFile","file","setOptions","modelComplexity","smoothLandmarks","enableSegmentation","smoothSegmentation","minDetectionConfidence","minTrackingConfidence","onResults","error","console","src","Promise","resolve","reject","document","querySelector","script","createElement","onload","onerror","head","appendChild","poseNet","current","video","canvas","processFrame","paused","ended","rect","getBoundingClientRect","width","height","estimateSinglePose","flipHorizontal","score","drawPose","keypoints","requestAnimationFrame","readyState","addEventListener","once","ctx","getContext","clearRect","videoRect","videoAspect","videoWidth","videoHeight","displayAspect","scaleX","scaleY","offsetX","offsetY","forEach","i","j","kp1","kp2","beginPath","moveTo","position","x","y","lineTo","strokeStyle","lineWidth","stroke","keypoint","index","arc","Math","PI","fillStyle","fill","ref","style","top","left","pointerEvents","zIndex","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Fit/frontend/src/components/KeypointOverlay.js"],"sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\r\n\r\nconst KeypointOverlay = ({ videoRef, isPlaying, onKeypointsDetected }) => {\r\n  const canvasRef = useRef(null);\r\n  const [isInitialized, setIsInitialized] = useState(false);\r\n  const [pose, setPose] = useState(null);\r\n\r\n  // MediaPipe Pose connections (33 landmarks)\r\n  const POSE_CONNECTIONS = [\r\n    // Face\r\n    [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8],\r\n    // Arms\r\n    [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19],\r\n    [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20],\r\n    // Body\r\n    [11, 23], [12, 24], [23, 24],\r\n    // Legs\r\n    [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]\r\n  ];\r\n\r\n  useEffect(() => {\r\n    const initializeMediaPipe = async () => {\r\n      try {\r\n        // โหลด MediaPipe จาก CDN\r\n        if (!window.Pose) {\r\n          // โหลด scripts จาก CDN\r\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js');\r\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js');\r\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js');\r\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js');\r\n        }\r\n\r\n        const poseInstance = new window.Pose({\r\n          locateFile: (file) => {\r\n            return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\r\n          }\r\n        });\r\n\r\n        poseInstance.setOptions({\r\n          modelComplexity: 1,\r\n          smoothLandmarks: true,\r\n          enableSegmentation: false,\r\n          smoothSegmentation: true,\r\n          minDetectionConfidence: 0.5,\r\n          minTrackingConfidence: 0.5\r\n        });\r\n\r\n        poseInstance.onResults(onResults);\r\n        setPose(poseInstance);\r\n        setIsInitialized(true);\r\n      } catch (error) {\r\n        console.error('Failed to load MediaPipe:', error);\r\n      }\r\n    };\r\n\r\n    initializeMediaPipe();\r\n  }, []);\r\n\r\n  // Helper function to load scripts\r\n  const loadScript = (src) => {\r\n    return new Promise((resolve, reject) => {\r\n      if (document.querySelector(`script[src=\"${src}\"]`)) {\r\n        resolve();\r\n        return;\r\n      }\r\n      const script = document.createElement('script');\r\n      script.src = src;\r\n      script.onload = resolve;\r\n      script.onerror = reject;\r\n      document.head.appendChild(script);\r\n    });\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (!isInitialized || !poseNet || !videoRef?.current || !canvasRef.current) return;\r\n\r\n    const video = videoRef.current;\r\n    const canvas = canvasRef.current;\r\n    \r\n    const processFrame = async () => {\r\n      if (video.paused || video.ended || !isPlaying) return;\r\n      \r\n      try {\r\n        // Match canvas size to video display size\r\n        const rect = video.getBoundingClientRect();\r\n        canvas.width = rect.width;\r\n        canvas.height = rect.height;\r\n        \r\n        // Estimate pose\r\n        const pose = await poseNet.estimateSinglePose(video, {\r\n          flipHorizontal: false\r\n        });\r\n\r\n        if (pose && pose.score > 0.3) {\r\n          drawPose(pose, canvas, video);\r\n          \r\n          if (onKeypointsDetected) {\r\n            onKeypointsDetected(pose.keypoints);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error('Pose detection error:', error);\r\n      }\r\n\r\n      if (isPlaying && !video.paused && !video.ended) {\r\n        requestAnimationFrame(processFrame);\r\n      }\r\n    };\r\n\r\n    if (isPlaying) {\r\n      if (video.readyState >= 2) {\r\n        processFrame();\r\n      } else {\r\n        video.addEventListener('loadeddata', processFrame, { once: true });\r\n      }\r\n    }\r\n\r\n    // Clean up canvas when not playing\r\n    if (!isPlaying) {\r\n      const ctx = canvas.getContext('2d');\r\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    }\r\n  }, [isPlaying, isInitialized, poseNet]);\r\n\r\n  const drawPose = (pose, canvas, video) => {\r\n    const ctx = canvas.getContext('2d');\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    // Calculate proper scaling to match video display\r\n    const videoRect = video.getBoundingClientRect();\r\n    const videoAspect = video.videoWidth / video.videoHeight;\r\n    const displayAspect = videoRect.width / videoRect.height;\r\n    \r\n    let scaleX, scaleY, offsetX = 0, offsetY = 0;\r\n    \r\n    if (videoAspect > displayAspect) {\r\n      // Video is wider - fit by width\r\n      scaleX = videoRect.width / video.videoWidth;\r\n      scaleY = scaleX;\r\n      offsetY = (videoRect.height - video.videoHeight * scaleY) / 2;\r\n    } else {\r\n      // Video is taller - fit by height\r\n      scaleY = videoRect.height / video.videoHeight;\r\n      scaleX = scaleY;\r\n      offsetX = (videoRect.width - video.videoWidth * scaleX) / 2;\r\n    }\r\n\r\n    // Draw skeleton connections with normalized coordinates\r\n    POSE_CONNECTIONS.forEach(([i, j]) => {\r\n      const kp1 = pose.keypoints[i];\r\n      const kp2 = pose.keypoints[j];\r\n      \r\n      if (kp1.score > 0.3 && kp2.score > 0.3) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(\r\n          kp1.position.x * scaleX + offsetX,\r\n          kp1.position.y * scaleY + offsetY\r\n        );\r\n        ctx.lineTo(\r\n          kp2.position.x * scaleX + offsetX,\r\n          kp2.position.y * scaleY + offsetY\r\n        );\r\n        ctx.strokeStyle = '#00FF00';\r\n        ctx.lineWidth = 2;\r\n        ctx.stroke();\r\n      }\r\n    });\r\n\r\n    // Draw keypoints with normalized coordinates\r\n    pose.keypoints.forEach((keypoint, index) => {\r\n      if (keypoint.score > 0.3) {\r\n        ctx.beginPath();\r\n        ctx.arc(\r\n          keypoint.position.x * scaleX + offsetX,\r\n          keypoint.position.y * scaleY + offsetY,\r\n          3,\r\n          0,\r\n          2 * Math.PI\r\n        );\r\n        \r\n        // Different colors for different body parts\r\n        if (index <= 4) ctx.fillStyle = '#FF6B6B'; // Head\r\n        else if (index <= 10) ctx.fillStyle = '#4ECDC4'; // Arms  \r\n        else ctx.fillStyle = '#45B7D1'; // Body & Legs\r\n        \r\n        ctx.fill();\r\n      }\r\n    });\r\n  };\r\n\r\n  return (\r\n    <canvas\r\n      ref={canvasRef}\r\n      style={{\r\n        position: 'absolute',\r\n        top: 0,\r\n        left: 0,\r\n        width: '100%',\r\n        height: '100%',\r\n        pointerEvents: 'none',\r\n        zIndex: 10\r\n      }}\r\n    />\r\n  );\r\n};\r\n\r\nexport default KeypointOverlay;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}