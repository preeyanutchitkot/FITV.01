{"ast":null,"code":"var _jsxFileName = \"C:\\\\Fit\\\\frontend\\\\src\\\\components\\\\KeypointOverlay.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst KeypointOverlay = ({\n  videoRef,\n  isPlaying,\n  onKeypointsDetected\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [pose, setPose] = useState(null);\n\n  // MediaPipe Pose connections (33 landmarks)\n  const POSE_CONNECTIONS = [\n  // Face\n  [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8],\n  // Arms\n  [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19], [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20],\n  // Body\n  [11, 23], [12, 24], [23, 24],\n  // Legs\n  [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]];\n  useEffect(() => {\n    const initializeMediaPipe = async () => {\n      try {\n        console.log('Starting MediaPipe initialization...');\n\n        // Check if already loaded\n        if (window.Pose && window.Camera && window.drawConnectors) {\n          console.log('MediaPipe already loaded');\n        } else {\n          console.log('Loading MediaPipe scripts...');\n\n          // Load MediaPipe scripts in sequence\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js');\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js');\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.js');\n\n          // Wait for initialization\n          await new Promise(resolve => setTimeout(resolve, 500));\n          console.log('MediaPipe scripts loaded');\n        }\n\n        // Verify MediaPipe is available\n        if (!window.Pose) {\n          throw new Error('MediaPipe Pose not available');\n        }\n\n        // Check what's available\n        console.log('MediaPipe objects available:', {\n          Pose: typeof window.Pose,\n          Camera: typeof window.Camera,\n          drawConnectors: typeof window.drawConnectors,\n          drawLandmarks: typeof window.drawLandmarks,\n          POSE_CONNECTIONS: typeof window.POSE_CONNECTIONS\n        });\n        console.log('Creating Pose instance...');\n        const poseInstance = new window.Pose({\n          locateFile: file => {\n            return `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${file}`;\n          }\n        });\n        poseInstance.setOptions({\n          modelComplexity: 1,\n          smoothLandmarks: true,\n          enableSegmentation: false,\n          smoothSegmentation: true,\n          minDetectionConfidence: 0.5,\n          minTrackingConfidence: 0.5\n        });\n        poseInstance.onResults(onResults);\n\n        // Test if MediaPipe is working properly\n        await new Promise((resolve, reject) => {\n          const timeout = setTimeout(() => reject(new Error('MediaPipe initialization timeout')), 5000);\n\n          // Set up a test callback\n          const originalOnResults = onResults;\n          poseInstance.onResults(results => {\n            clearTimeout(timeout);\n            poseInstance.onResults(originalOnResults);\n            resolve();\n          });\n\n          // Initialize with a simple test\n          setPose(poseInstance);\n        });\n        setIsInitialized(true);\n        console.log('MediaPipe Pose initialized successfully');\n      } catch (error) {\n        console.error('Failed to load MediaPipe:', error);\n        // Try fallback with different CDN\n        await initializeMediaPipeFallback();\n      }\n    };\n    const initializeMediaPipeFallback = async () => {\n      try {\n        console.log('Trying MediaPipe fallback...');\n\n        // ลองใช้ CDN เวอร์ชันเก่าที่เสถียร\n        if (!window.Pose) {\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.4.1633559619/pose.js');\n        }\n        if (window.Pose) {\n          const poseInstance = new window.Pose({\n            locateFile: file => {\n              return `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.4.1633559619/${file}`;\n            }\n          });\n          poseInstance.setOptions({\n            modelComplexity: 0,\n            // ลดความซับซ้อนสำหรับ fallback\n            smoothLandmarks: false,\n            enableSegmentation: false,\n            minDetectionConfidence: 0.3,\n            minTrackingConfidence: 0.3\n          });\n          poseInstance.onResults(onResults);\n          setPose(poseInstance);\n          setIsInitialized(true);\n          console.log('MediaPipe fallback initialized');\n        } else {\n          throw new Error('MediaPipe not available');\n        }\n      } catch (fallbackError) {\n        console.error('MediaPipe fallback also failed:', fallbackError);\n        // ใช้ setTimeout เพื่อ retry\n        setTimeout(() => {\n          console.log('Retrying MediaPipe initialization...');\n          initializeMediaPipe();\n        }, 2000);\n      }\n    };\n    initializeMediaPipe();\n  }, []);\n\n  // Cleanup effect\n  useEffect(() => {\n    return () => {\n      if (pose) {\n        pose.close();\n      }\n    };\n  }, [pose]);\n\n  // Helper function to load scripts with proper module handling\n  const loadScript = src => {\n    return new Promise((resolve, reject) => {\n      // Check if script already exists\n      const existingScript = document.querySelector(`script[src=\"${src}\"]`);\n      if (existingScript) {\n        resolve();\n        return;\n      }\n      const script = document.createElement('script');\n      script.src = src;\n      script.crossOrigin = 'anonymous';\n\n      // Don't set type=\"module\" to avoid ES module issues\n      // Use traditional script loading for MediaPipe UMD builds\n\n      // Add timeout\n      const timeout = setTimeout(() => {\n        script.remove();\n        reject(new Error(`Script loading timeout: ${src}`));\n      }, 15000); // Increase timeout\n\n      script.onload = () => {\n        clearTimeout(timeout);\n        console.log('Script loaded:', src);\n        resolve();\n      };\n      script.onerror = error => {\n        clearTimeout(timeout);\n        console.error('Script loading failed:', src, error);\n        reject(error);\n      };\n      document.head.appendChild(script);\n    });\n  };\n  useEffect(() => {\n    if (!isInitialized || !pose || !(videoRef !== null && videoRef !== void 0 && videoRef.current) || !canvasRef.current) return;\n    const video = videoRef.current;\n    const canvas = canvasRef.current;\n    let isProcessing = false;\n    let lastProcessTime = 0;\n    const targetFPS = 15; // Limit to 15 FPS for better performance\n    const frameInterval = 1000 / targetFPS;\n    const processFrame = async () => {\n      // Skip if already processing or not playing\n      if (isProcessing || video.paused || video.ended || !isPlaying) {\n        if (isPlaying && !video.paused && !video.ended) {\n          requestAnimationFrame(processFrame);\n        }\n        return;\n      }\n\n      // Throttle frame processing\n      const now = Date.now();\n      if (now - lastProcessTime < frameInterval) {\n        requestAnimationFrame(processFrame);\n        return;\n      }\n      isProcessing = true;\n      lastProcessTime = now;\n      try {\n        // Match canvas size to video element's display size exactly\n        const rect = video.getBoundingClientRect();\n        if (canvas.width !== rect.width || canvas.height !== rect.height) {\n          canvas.width = rect.width;\n          canvas.height = rect.height;\n          console.log('Canvas resized to:', rect.width, 'x', rect.height);\n        }\n\n        // Make sure video is ready and has valid dimensions\n        if (video.readyState >= video.HAVE_CURRENT_DATA && (video.videoWidth > 0 || video.srcObject)) {\n          console.log('Sending frame to MediaPipe...', {\n            videoWidth: video.videoWidth,\n            videoHeight: video.videoHeight,\n            canvasWidth: canvas.width,\n            canvasHeight: canvas.height\n          });\n\n          // Send frame to MediaPipe with timeout\n          const sendPromise = pose.send({\n            image: video\n          });\n          const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('MediaPipe processing timeout')), 2000));\n          await Promise.race([sendPromise, timeoutPromise]);\n          console.log('Frame sent successfully');\n        }\n      } catch (error) {\n        console.error('Pose detection error:', error);\n      } finally {\n        isProcessing = false;\n      }\n\n      // Continue processing if still playing\n      if (isPlaying && !video.paused && !video.ended) {\n        requestAnimationFrame(processFrame);\n      }\n    };\n    if (isPlaying) {\n      // Start processing for camera stream or loaded video\n      if (video.readyState >= 2 || video.srcObject) {\n        console.log('Starting pose detection...');\n        processFrame();\n      } else {\n        console.log('Waiting for video to load...');\n        video.addEventListener('loadeddata', () => {\n          console.log('Video loaded, starting pose detection...');\n          processFrame();\n        }, {\n          once: true\n        });\n      }\n    }\n\n    // Clean up canvas when not playing\n    if (!isPlaying) {\n      const ctx = canvas.getContext('2d');\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // Cleanup function\n    return () => {\n      isProcessing = false;\n    };\n  }, [isPlaying, isInitialized, pose]);\n  const onResults = results => {\n    console.log('onResults called:', results ? 'with results' : 'no results');\n    const canvas = canvasRef.current;\n    const video = videoRef.current;\n    if (!canvas || !video) {\n      console.log('No canvas or video reference');\n      return;\n    }\n\n    // Clear previous drawings\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    if (!results.poseLandmarks || results.poseLandmarks.length === 0) {\n      console.log('No pose landmarks detected');\n      return;\n    }\n    console.log('Drawing pose landmarks:', results.poseLandmarks.length, 'points');\n    try {\n      // Use MediaPipe's built-in drawing functions if available\n      if (window.drawConnectors && window.drawLandmarks && window.POSE_CONNECTIONS) {\n        console.log('Using MediaPipe drawing functions');\n\n        // Save canvas state\n        ctx.save();\n\n        // Draw connections\n        window.drawConnectors(ctx, results.poseLandmarks, window.POSE_CONNECTIONS, {\n          color: '#00FF00',\n          lineWidth: 2\n        });\n\n        // Draw landmarks\n        window.drawLandmarks(ctx, results.poseLandmarks, {\n          color: '#FF0000',\n          radius: 3\n        });\n        ctx.restore();\n      } else {\n        console.log('Using custom drawing function');\n        drawPoseMediaPipe(results.poseLandmarks, canvas, video);\n      }\n      if (onKeypointsDetected) {\n        // Always mirror the keypoints to match the CSS mirrored video display\n        const mirroredLandmarks = results.poseLandmarks.map(landmark => ({\n          ...landmark,\n          x: 1 - landmark.x // Mirror X coordinate to match video transform\n        }));\n        onKeypointsDetected(mirroredLandmarks);\n      }\n    } catch (error) {\n      console.error('Drawing error:', error);\n    }\n  };\n  const drawPoseMediaPipe = (landmarks, canvas, video) => {\n    const ctx = canvas.getContext('2d');\n    // Canvas is already cleared in onResults\n\n    // Get actual video dimensions and display dimensions\n    const videoRect = video.getBoundingClientRect();\n    const videoWidth = video.videoWidth;\n    const videoHeight = video.videoHeight;\n    const displayWidth = videoRect.width;\n    const displayHeight = videoRect.height;\n\n    // Calculate aspect ratios\n    const videoAspect = videoWidth / videoHeight;\n    const displayAspect = displayWidth / displayHeight;\n\n    // Calculate actual video display area within the video element\n    let actualVideoWidth,\n      actualVideoHeight,\n      offsetX = 0,\n      offsetY = 0;\n    if (videoAspect > displayAspect) {\n      // Video is wider - letterboxed top/bottom\n      actualVideoWidth = displayWidth;\n      actualVideoHeight = displayWidth / videoAspect;\n      offsetY = (displayHeight - actualVideoHeight) / 2;\n    } else {\n      // Video is taller - letterboxed left/right\n      actualVideoHeight = displayHeight;\n      actualVideoWidth = displayHeight * videoAspect;\n      offsetX = (displayWidth - actualVideoWidth) / 2;\n    }\n\n    // MediaPipe landmarks are normalized (0-1), scale to actual video area\n    const scaleX = actualVideoWidth;\n    const scaleY = actualVideoHeight;\n\n    // Note: Video has CSS transform: scaleX(-1) to mirror the display\n    // So we need to mirror the keypoints coordinates to match\n\n    // Draw skeleton connections\n    POSE_CONNECTIONS.forEach(([i, j]) => {\n      const kp1 = landmarks[i];\n      const kp2 = landmarks[j];\n      if (kp1 && kp2 && kp1.visibility > 0.5 && kp2.visibility > 0.5) {\n        // Always mirror X coordinates to match the CSS transform: scaleX(-1) on video\n        const x1 = (1 - kp1.x) * scaleX + offsetX;\n        const y1 = kp1.y * scaleY + offsetY;\n        const x2 = (1 - kp2.x) * scaleX + offsetX;\n        const y2 = kp2.y * scaleY + offsetY;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.strokeStyle = '#00FF00';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n      }\n    });\n\n    // Draw keypoints with different colors\n    landmarks.forEach((landmark, index) => {\n      if (landmark && landmark.visibility > 0.5) {\n        // Always mirror X coordinates to match the CSS transform: scaleX(-1) on video\n        const x = (1 - landmark.x) * scaleX + offsetX;\n        const y = landmark.y * scaleY + offsetY;\n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n\n        // Different colors for different body parts\n        if (index <= 10) {\n          ctx.fillStyle = '#FF6B6B'; // Face and upper body\n        } else if (index <= 16) {\n          ctx.fillStyle = '#4ECDC4'; // Arms\n        } else if (index <= 22) {\n          ctx.fillStyle = '#45B7D1'; // Hands\n        } else {\n          ctx.fillStyle = '#96CEB4'; // Legs and body\n        }\n        ctx.fill();\n\n        // Add white border for better visibility\n        ctx.beginPath();\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\n        ctx.strokeStyle = '#FFFFFF';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n      }\n    });\n  };\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      zIndex: 10\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 442,\n    columnNumber: 5\n  }, this);\n};\n_s(KeypointOverlay, \"m2C8+nABSeOQUESm7cHppPmlwFM=\");\n_c = KeypointOverlay;\nexport default KeypointOverlay;\nvar _c;\n$RefreshReg$(_c, \"KeypointOverlay\");","map":{"version":3,"names":["React","useRef","useEffect","useState","jsxDEV","_jsxDEV","KeypointOverlay","videoRef","isPlaying","onKeypointsDetected","_s","canvasRef","isInitialized","setIsInitialized","pose","setPose","POSE_CONNECTIONS","initializeMediaPipe","console","log","window","Pose","Camera","drawConnectors","loadScript","Promise","resolve","setTimeout","Error","drawLandmarks","poseInstance","locateFile","file","setOptions","modelComplexity","smoothLandmarks","enableSegmentation","smoothSegmentation","minDetectionConfidence","minTrackingConfidence","onResults","reject","timeout","originalOnResults","results","clearTimeout","error","initializeMediaPipeFallback","fallbackError","close","src","existingScript","document","querySelector","script","createElement","crossOrigin","remove","onload","onerror","head","appendChild","current","video","canvas","isProcessing","lastProcessTime","targetFPS","frameInterval","processFrame","paused","ended","requestAnimationFrame","now","Date","rect","getBoundingClientRect","width","height","readyState","HAVE_CURRENT_DATA","videoWidth","srcObject","videoHeight","canvasWidth","canvasHeight","sendPromise","send","image","timeoutPromise","_","race","addEventListener","once","ctx","getContext","clearRect","poseLandmarks","length","save","color","lineWidth","radius","restore","drawPoseMediaPipe","mirroredLandmarks","map","landmark","x","landmarks","videoRect","displayWidth","displayHeight","videoAspect","displayAspect","actualVideoWidth","actualVideoHeight","offsetX","offsetY","scaleX","scaleY","forEach","i","j","kp1","kp2","visibility","x1","y1","y","x2","y2","beginPath","moveTo","lineTo","strokeStyle","stroke","index","arc","Math","PI","fillStyle","fill","ref","style","position","top","left","pointerEvents","zIndex","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Fit/frontend/src/components/KeypointOverlay.js"],"sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\r\n\r\nconst KeypointOverlay = ({ videoRef, isPlaying, onKeypointsDetected }) => {\r\n  const canvasRef = useRef(null);\r\n  const [isInitialized, setIsInitialized] = useState(false);\r\n  const [pose, setPose] = useState(null);\r\n\r\n  // MediaPipe Pose connections (33 landmarks)\r\n  const POSE_CONNECTIONS = [\r\n    // Face\r\n    [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8],\r\n    // Arms\r\n    [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19],\r\n    [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20],\r\n    // Body\r\n    [11, 23], [12, 24], [23, 24],\r\n    // Legs\r\n    [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]\r\n  ];\r\n\r\n  useEffect(() => {\r\n    const initializeMediaPipe = async () => {\r\n      try {\r\n        console.log('Starting MediaPipe initialization...');\r\n        \r\n        // Check if already loaded\r\n        if (window.Pose && window.Camera && window.drawConnectors) {\r\n          console.log('MediaPipe already loaded');\r\n        } else {\r\n          console.log('Loading MediaPipe scripts...');\r\n          \r\n          // Load MediaPipe scripts in sequence\r\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js');\r\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js');\r\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.js');\r\n          \r\n          // Wait for initialization\r\n          await new Promise(resolve => setTimeout(resolve, 500));\r\n          \r\n          console.log('MediaPipe scripts loaded');\r\n        }\r\n\r\n        // Verify MediaPipe is available\r\n        if (!window.Pose) {\r\n          throw new Error('MediaPipe Pose not available');\r\n        }\r\n\r\n        // Check what's available\r\n        console.log('MediaPipe objects available:', {\r\n          Pose: typeof window.Pose,\r\n          Camera: typeof window.Camera,\r\n          drawConnectors: typeof window.drawConnectors,\r\n          drawLandmarks: typeof window.drawLandmarks,\r\n          POSE_CONNECTIONS: typeof window.POSE_CONNECTIONS\r\n        });\r\n\r\n        console.log('Creating Pose instance...');\r\n        const poseInstance = new window.Pose({\r\n          locateFile: (file) => {\r\n            return `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${file}`;\r\n          }\r\n        });\r\n\r\n        poseInstance.setOptions({\r\n          modelComplexity: 1,\r\n          smoothLandmarks: true,\r\n          enableSegmentation: false,\r\n          smoothSegmentation: true,\r\n          minDetectionConfidence: 0.5,\r\n          minTrackingConfidence: 0.5\r\n        });\r\n\r\n        poseInstance.onResults(onResults);\r\n        \r\n        // Test if MediaPipe is working properly\r\n        await new Promise((resolve, reject) => {\r\n          const timeout = setTimeout(() => reject(new Error('MediaPipe initialization timeout')), 5000);\r\n          \r\n          // Set up a test callback\r\n          const originalOnResults = onResults;\r\n          poseInstance.onResults((results) => {\r\n            clearTimeout(timeout);\r\n            poseInstance.onResults(originalOnResults);\r\n            resolve();\r\n          });\r\n          \r\n          // Initialize with a simple test\r\n          setPose(poseInstance);\r\n        });\r\n        \r\n        setIsInitialized(true);\r\n        console.log('MediaPipe Pose initialized successfully');\r\n      } catch (error) {\r\n        console.error('Failed to load MediaPipe:', error);\r\n        // Try fallback with different CDN\r\n        await initializeMediaPipeFallback();\r\n      }\r\n    };\r\n\r\n    const initializeMediaPipeFallback = async () => {\r\n      try {\r\n        console.log('Trying MediaPipe fallback...');\r\n        \r\n        // ลองใช้ CDN เวอร์ชันเก่าที่เสถียร\r\n        if (!window.Pose) {\r\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.4.1633559619/pose.js');\r\n        }\r\n        \r\n        if (window.Pose) {\r\n          const poseInstance = new window.Pose({\r\n            locateFile: (file) => {\r\n              return `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.4.1633559619/${file}`;\r\n            }\r\n          });\r\n\r\n          poseInstance.setOptions({\r\n            modelComplexity: 0, // ลดความซับซ้อนสำหรับ fallback\r\n            smoothLandmarks: false,\r\n            enableSegmentation: false,\r\n            minDetectionConfidence: 0.3,\r\n            minTrackingConfidence: 0.3\r\n          });\r\n\r\n          poseInstance.onResults(onResults);\r\n          setPose(poseInstance);\r\n          setIsInitialized(true);\r\n          console.log('MediaPipe fallback initialized');\r\n        } else {\r\n          throw new Error('MediaPipe not available');\r\n        }\r\n      } catch (fallbackError) {\r\n        console.error('MediaPipe fallback also failed:', fallbackError);\r\n        // ใช้ setTimeout เพื่อ retry\r\n        setTimeout(() => {\r\n          console.log('Retrying MediaPipe initialization...');\r\n          initializeMediaPipe();\r\n        }, 2000);\r\n      }\r\n    };\r\n\r\n    initializeMediaPipe();\r\n  }, []);\r\n\r\n  // Cleanup effect\r\n  useEffect(() => {\r\n    return () => {\r\n      if (pose) {\r\n        pose.close();\r\n      }\r\n    };\r\n  }, [pose]);\r\n\r\n  // Helper function to load scripts with proper module handling\r\n  const loadScript = (src) => {\r\n    return new Promise((resolve, reject) => {\r\n      // Check if script already exists\r\n      const existingScript = document.querySelector(`script[src=\"${src}\"]`);\r\n      if (existingScript) {\r\n        resolve();\r\n        return;\r\n      }\r\n      \r\n      const script = document.createElement('script');\r\n      script.src = src;\r\n      script.crossOrigin = 'anonymous';\r\n      \r\n      // Don't set type=\"module\" to avoid ES module issues\r\n      // Use traditional script loading for MediaPipe UMD builds\r\n      \r\n      // Add timeout\r\n      const timeout = setTimeout(() => {\r\n        script.remove();\r\n        reject(new Error(`Script loading timeout: ${src}`));\r\n      }, 15000); // Increase timeout\r\n      \r\n      script.onload = () => {\r\n        clearTimeout(timeout);\r\n        console.log('Script loaded:', src);\r\n        resolve();\r\n      };\r\n      \r\n      script.onerror = (error) => {\r\n        clearTimeout(timeout);\r\n        console.error('Script loading failed:', src, error);\r\n        reject(error);\r\n      };\r\n      \r\n      document.head.appendChild(script);\r\n    });\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (!isInitialized || !pose || !videoRef?.current || !canvasRef.current) return;\r\n\r\n    const video = videoRef.current;\r\n    const canvas = canvasRef.current;\r\n    \r\n    let isProcessing = false;\r\n    let lastProcessTime = 0;\r\n    const targetFPS = 15; // Limit to 15 FPS for better performance\r\n    const frameInterval = 1000 / targetFPS;\r\n    \r\n    const processFrame = async () => {\r\n      // Skip if already processing or not playing\r\n      if (isProcessing || video.paused || video.ended || !isPlaying) {\r\n        if (isPlaying && !video.paused && !video.ended) {\r\n          requestAnimationFrame(processFrame);\r\n        }\r\n        return;\r\n      }\r\n      \r\n      // Throttle frame processing\r\n      const now = Date.now();\r\n      if (now - lastProcessTime < frameInterval) {\r\n        requestAnimationFrame(processFrame);\r\n        return;\r\n      }\r\n      \r\n      isProcessing = true;\r\n      lastProcessTime = now;\r\n      \r\n      try {\r\n        // Match canvas size to video element's display size exactly\r\n        const rect = video.getBoundingClientRect();\r\n        if (canvas.width !== rect.width || canvas.height !== rect.height) {\r\n          canvas.width = rect.width;\r\n          canvas.height = rect.height;\r\n          console.log('Canvas resized to:', rect.width, 'x', rect.height);\r\n        }\r\n        \r\n        // Make sure video is ready and has valid dimensions\r\n        if (video.readyState >= video.HAVE_CURRENT_DATA && \r\n            (video.videoWidth > 0 || video.srcObject)) {\r\n          \r\n          console.log('Sending frame to MediaPipe...', {\r\n            videoWidth: video.videoWidth,\r\n            videoHeight: video.videoHeight,\r\n            canvasWidth: canvas.width,\r\n            canvasHeight: canvas.height\r\n          });\r\n          \r\n          // Send frame to MediaPipe with timeout\r\n          const sendPromise = pose.send({ image: video });\r\n          const timeoutPromise = new Promise((_, reject) => \r\n            setTimeout(() => reject(new Error('MediaPipe processing timeout')), 2000)\r\n          );\r\n          \r\n          await Promise.race([sendPromise, timeoutPromise]);\r\n          console.log('Frame sent successfully');\r\n        }\r\n      } catch (error) {\r\n        console.error('Pose detection error:', error);\r\n      } finally {\r\n        isProcessing = false;\r\n      }\r\n\r\n      // Continue processing if still playing\r\n      if (isPlaying && !video.paused && !video.ended) {\r\n        requestAnimationFrame(processFrame);\r\n      }\r\n    };\r\n\r\n    if (isPlaying) {\r\n      // Start processing for camera stream or loaded video\r\n      if (video.readyState >= 2 || video.srcObject) {\r\n        console.log('Starting pose detection...');\r\n        processFrame();\r\n      } else {\r\n        console.log('Waiting for video to load...');\r\n        video.addEventListener('loadeddata', () => {\r\n          console.log('Video loaded, starting pose detection...');\r\n          processFrame();\r\n        }, { once: true });\r\n      }\r\n    }\r\n\r\n    // Clean up canvas when not playing\r\n    if (!isPlaying) {\r\n      const ctx = canvas.getContext('2d');\r\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    }\r\n\r\n    // Cleanup function\r\n    return () => {\r\n      isProcessing = false;\r\n    };\r\n  }, [isPlaying, isInitialized, pose]);\r\n\r\n  const onResults = (results) => {\r\n    console.log('onResults called:', results ? 'with results' : 'no results');\r\n    \r\n    const canvas = canvasRef.current;\r\n    const video = videoRef.current;\r\n    \r\n    if (!canvas || !video) {\r\n      console.log('No canvas or video reference');\r\n      return;\r\n    }\r\n    \r\n    // Clear previous drawings\r\n    const ctx = canvas.getContext('2d');\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    \r\n    if (!results.poseLandmarks || results.poseLandmarks.length === 0) {\r\n      console.log('No pose landmarks detected');\r\n      return;\r\n    }\r\n\r\n    console.log('Drawing pose landmarks:', results.poseLandmarks.length, 'points');\r\n\r\n    try {\r\n      // Use MediaPipe's built-in drawing functions if available\r\n      if (window.drawConnectors && window.drawLandmarks && window.POSE_CONNECTIONS) {\r\n        console.log('Using MediaPipe drawing functions');\r\n        \r\n        // Save canvas state\r\n        ctx.save();\r\n        \r\n        // Draw connections\r\n        window.drawConnectors(ctx, results.poseLandmarks, window.POSE_CONNECTIONS, {\r\n          color: '#00FF00',\r\n          lineWidth: 2\r\n        });\r\n        \r\n        // Draw landmarks\r\n        window.drawLandmarks(ctx, results.poseLandmarks, {\r\n          color: '#FF0000',\r\n          radius: 3\r\n        });\r\n        \r\n        ctx.restore();\r\n      } else {\r\n        console.log('Using custom drawing function');\r\n        drawPoseMediaPipe(results.poseLandmarks, canvas, video);\r\n      }\r\n      \r\n      if (onKeypointsDetected) {\r\n        // Always mirror the keypoints to match the CSS mirrored video display\r\n        const mirroredLandmarks = results.poseLandmarks.map(landmark => ({\r\n          ...landmark,\r\n          x: 1 - landmark.x  // Mirror X coordinate to match video transform\r\n        }));\r\n        onKeypointsDetected(mirroredLandmarks);\r\n      }\r\n    } catch (error) {\r\n      console.error('Drawing error:', error);\r\n    }\r\n  };\r\n\r\n  const drawPoseMediaPipe = (landmarks, canvas, video) => {\r\n    const ctx = canvas.getContext('2d');\r\n    // Canvas is already cleared in onResults\r\n\r\n    // Get actual video dimensions and display dimensions\r\n    const videoRect = video.getBoundingClientRect();\r\n    const videoWidth = video.videoWidth;\r\n    const videoHeight = video.videoHeight;\r\n    const displayWidth = videoRect.width;\r\n    const displayHeight = videoRect.height;\r\n\r\n    // Calculate aspect ratios\r\n    const videoAspect = videoWidth / videoHeight;\r\n    const displayAspect = displayWidth / displayHeight;\r\n\r\n    // Calculate actual video display area within the video element\r\n    let actualVideoWidth, actualVideoHeight, offsetX = 0, offsetY = 0;\r\n\r\n    if (videoAspect > displayAspect) {\r\n      // Video is wider - letterboxed top/bottom\r\n      actualVideoWidth = displayWidth;\r\n      actualVideoHeight = displayWidth / videoAspect;\r\n      offsetY = (displayHeight - actualVideoHeight) / 2;\r\n    } else {\r\n      // Video is taller - letterboxed left/right\r\n      actualVideoHeight = displayHeight;\r\n      actualVideoWidth = displayHeight * videoAspect;\r\n      offsetX = (displayWidth - actualVideoWidth) / 2;\r\n    }\r\n\r\n    // MediaPipe landmarks are normalized (0-1), scale to actual video area\r\n    const scaleX = actualVideoWidth;\r\n    const scaleY = actualVideoHeight;\r\n\r\n    // Note: Video has CSS transform: scaleX(-1) to mirror the display\r\n    // So we need to mirror the keypoints coordinates to match\r\n    \r\n    // Draw skeleton connections\r\n    POSE_CONNECTIONS.forEach(([i, j]) => {\r\n      const kp1 = landmarks[i];\r\n      const kp2 = landmarks[j];\r\n      \r\n      if (kp1 && kp2 && kp1.visibility > 0.5 && kp2.visibility > 0.5) {\r\n        // Always mirror X coordinates to match the CSS transform: scaleX(-1) on video\r\n        const x1 = (1 - kp1.x) * scaleX + offsetX;\r\n        const y1 = kp1.y * scaleY + offsetY;\r\n        const x2 = (1 - kp2.x) * scaleX + offsetX;\r\n        const y2 = kp2.y * scaleY + offsetY;\r\n        \r\n        ctx.beginPath();\r\n        ctx.moveTo(x1, y1);\r\n        ctx.lineTo(x2, y2);\r\n        ctx.strokeStyle = '#00FF00';\r\n        ctx.lineWidth = 2;\r\n        ctx.stroke();\r\n      }\r\n    });\r\n\r\n    // Draw keypoints with different colors\r\n    landmarks.forEach((landmark, index) => {\r\n      if (landmark && landmark.visibility > 0.5) {\r\n        // Always mirror X coordinates to match the CSS transform: scaleX(-1) on video\r\n        const x = (1 - landmark.x) * scaleX + offsetX;\r\n        const y = landmark.y * scaleY + offsetY;\r\n        \r\n        ctx.beginPath();\r\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\r\n        \r\n        // Different colors for different body parts\r\n        if (index <= 10) {\r\n          ctx.fillStyle = '#FF6B6B'; // Face and upper body\r\n        } else if (index <= 16) {\r\n          ctx.fillStyle = '#4ECDC4'; // Arms\r\n        } else if (index <= 22) {\r\n          ctx.fillStyle = '#45B7D1'; // Hands\r\n        } else {\r\n          ctx.fillStyle = '#96CEB4'; // Legs and body\r\n        }\r\n        \r\n        ctx.fill();\r\n        \r\n        // Add white border for better visibility\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, 3, 0, 2 * Math.PI);\r\n        ctx.strokeStyle = '#FFFFFF';\r\n        ctx.lineWidth = 1;\r\n        ctx.stroke();\r\n      }\r\n    });\r\n  };\r\n\r\n  return (\r\n    <canvas\r\n      ref={canvasRef}\r\n      style={{\r\n        position: 'absolute',\r\n        top: 0,\r\n        left: 0,\r\n        width: '100%',\r\n        height: '100%',\r\n        pointerEvents: 'none',\r\n        zIndex: 10\r\n      }}\r\n    />\r\n  );\r\n};\r\n\r\nexport default KeypointOverlay;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}