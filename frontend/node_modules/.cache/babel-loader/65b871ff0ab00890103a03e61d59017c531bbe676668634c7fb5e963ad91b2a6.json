{"ast":null,"code":"var _jsxFileName = \"C:\\\\Fit\\\\frontend\\\\src\\\\components\\\\KeypointOverlay.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst KeypointOverlay = ({\n  videoRef,\n  isPlaying,\n  onKeypointsDetected\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [pose, setPose] = useState(null);\n\n  // MediaPipe Pose connections (33 landmarks)\n  const POSE_CONNECTIONS = [\n  // Face\n  [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8],\n  // Arms\n  [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19], [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20],\n  // Body\n  [11, 23], [12, 24], [23, 24],\n  // Legs\n  [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]];\n  useEffect(() => {\n    const initializeMediaPipe = async () => {\n      try {\n        // โหลด MediaPipe จาก CDN\n        if (!window.Pose) {\n          // โหลด scripts จาก CDN\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js');\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js');\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js');\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js');\n        }\n        const poseInstance = new window.Pose({\n          locateFile: file => {\n            return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\n          }\n        });\n        poseInstance.setOptions({\n          modelComplexity: 1,\n          smoothLandmarks: true,\n          enableSegmentation: false,\n          smoothSegmentation: true,\n          minDetectionConfidence: 0.5,\n          minTrackingConfidence: 0.5\n        });\n        poseInstance.onResults(onResults);\n        setPose(poseInstance);\n        setIsInitialized(true);\n      } catch (error) {\n        console.error('Failed to load MediaPipe:', error);\n      }\n    };\n    initializeMediaPipe();\n  }, []);\n\n  // Cleanup effect\n  useEffect(() => {\n    return () => {\n      if (pose) {\n        pose.close();\n      }\n    };\n  }, [pose]);\n\n  // Helper function to load scripts\n  const loadScript = src => {\n    return new Promise((resolve, reject) => {\n      if (document.querySelector(`script[src=\"${src}\"]`)) {\n        resolve();\n        return;\n      }\n      const script = document.createElement('script');\n      script.src = src;\n      script.onload = resolve;\n      script.onerror = reject;\n      document.head.appendChild(script);\n    });\n  };\n  useEffect(() => {\n    if (!isInitialized || !pose || !(videoRef !== null && videoRef !== void 0 && videoRef.current) || !canvasRef.current) return;\n    const video = videoRef.current;\n    const canvas = canvasRef.current;\n    const processFrame = async () => {\n      if (video.paused || video.ended || !isPlaying) return;\n      try {\n        // Match canvas size to video element's display size exactly\n        const rect = video.getBoundingClientRect();\n        if (canvas.width !== rect.width || canvas.height !== rect.height) {\n          canvas.width = rect.width;\n          canvas.height = rect.height;\n        }\n\n        // Send frame to MediaPipe\n        await pose.send({\n          image: video\n        });\n      } catch (error) {\n        console.error('Pose detection error:', error);\n      }\n      if (isPlaying && !video.paused && !video.ended) {\n        requestAnimationFrame(processFrame);\n      }\n    };\n    if (isPlaying) {\n      if (video.readyState >= 2 || video.srcObject) {\n        // Video file ready or camera stream\n        processFrame();\n      } else {\n        // Wait for video to load\n        const onVideoReady = () => {\n          console.log('Video ready, starting pose detection');\n          processFrame();\n        };\n        video.addEventListener('loadeddata', onVideoReady, {\n          once: true\n        });\n        video.addEventListener('loadedmetadata', onVideoReady, {\n          once: true\n        });\n      }\n    }\n\n    // Clean up canvas when not playing\n    if (!isPlaying) {\n      const ctx = canvas.getContext('2d');\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n  }, [isPlaying, isInitialized, pose]);\n\n  // Temporal smoothing function\n  const smoothLandmarks = (currentLandmarks, previousLandmarks, alpha = 0.3) => {\n    if (!previousLandmarks) return currentLandmarks;\n    return currentLandmarks.map((landmark, index) => {\n      const prev = previousLandmarks[index];\n      if (!prev || landmark.visibility < 0.5) return landmark;\n      return {\n        x: alpha * landmark.x + (1 - alpha) * prev.x,\n        y: alpha * landmark.y + (1 - alpha) * prev.y,\n        z: alpha * landmark.z + (1 - alpha) * prev.z,\n        visibility: Math.max(landmark.visibility, prev.visibility * 0.9)\n      };\n    });\n  };\n  const onResults = results => {\n    const canvas = canvasRef.current;\n    const video = videoRef.current;\n    if (!canvas || !video || !results.poseLandmarks || results.poseLandmarks.length === 0) {\n      var _results$poseLandmark;\n      console.log('Missing data for pose drawing:', {\n        canvas: !!canvas,\n        video: !!video,\n        landmarks: ((_results$poseLandmark = results.poseLandmarks) === null || _results$poseLandmark === void 0 ? void 0 : _results$poseLandmark.length) || 0\n      });\n      return;\n    }\n    try {\n      // Validate landmarks format\n      const validLandmarks = results.poseLandmarks.filter(landmark => landmark && typeof landmark.x === 'number' && typeof landmark.y === 'number' && typeof landmark.visibility === 'number' && landmark.x >= 0 && landmark.x <= 1 && landmark.y >= 0 && landmark.y <= 1);\n      if (validLandmarks.length < 20) {\n        // Need at least 20 valid landmarks\n        console.log('Not enough valid landmarks:', validLandmarks.length);\n        return;\n      }\n\n      // Apply temporal smoothing\n      const smoothed = smoothLandmarks(results.poseLandmarks, previousLandmarks);\n      setSmoothedLandmarks(smoothed);\n      setPreviousLandmarks(smoothed);\n      drawPoseMediaPipe(smoothed, canvas, video);\n      if (onKeypointsDetected) {\n        onKeypointsDetected(smoothed);\n      }\n    } catch (error) {\n      console.error('Drawing error:', error);\n    }\n  };\n  const drawPoseMediaPipe = (landmarks, canvas, video) => {\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Make sure canvas matches video element size\n    const videoRect = video.getBoundingClientRect();\n    canvas.width = videoRect.width;\n    canvas.height = videoRect.height;\n\n    // Get video dimensions - handle camera stream case\n    let videoWidth = video.videoWidth;\n    let videoHeight = video.videoHeight;\n\n    // For camera streams, dimensions might not be available immediately\n    if (!videoWidth || !videoHeight) {\n      // Wait for video metadata or use default camera resolution\n      if (video.srcObject) {\n        // Camera stream - use common webcam resolution\n        videoWidth = 640;\n        videoHeight = 480;\n      } else {\n        // Video file - wait for metadata\n        console.log('Video dimensions not available yet');\n        return;\n      }\n    }\n    const canvasWidth = canvas.width;\n    const canvasHeight = canvas.height;\n    console.log('Video dimensions:', videoWidth, 'x', videoHeight);\n    console.log('Canvas dimensions:', canvasWidth, 'x', canvasHeight);\n\n    // Calculate scale factors for proper normalization\n    // MediaPipe landmarks are normalized (0-1) relative to video dimensions\n    let scaleX,\n      scaleY,\n      offsetX = 0,\n      offsetY = 0;\n    if (video.style.objectFit === 'contain' || video.style.objectFit === '') {\n      // For object-fit: contain, we need to calculate the actual video display area\n      const videoAspect = videoWidth / videoHeight;\n      const canvasAspect = canvasWidth / canvasHeight;\n      if (videoAspect > canvasAspect) {\n        // Video is wider - fit to width, letterbox top/bottom\n        scaleX = canvasWidth;\n        scaleY = canvasWidth / videoAspect;\n        offsetY = (canvasHeight - scaleY) / 2;\n      } else {\n        // Video is taller - fit to height, letterbox left/right  \n        scaleY = canvasHeight;\n        scaleX = canvasHeight * videoAspect;\n        offsetX = (canvasWidth - scaleX) / 2;\n      }\n    } else {\n      // For object-fit: cover or other modes, scale to full canvas\n      scaleX = canvasWidth;\n      scaleY = canvasHeight;\n    }\n    console.log('Scale factors:', scaleX, scaleY, 'Offsets:', offsetX, offsetY);\n\n    // Draw skeleton connections with better visibility\n    if (showConnections) {\n      // Shadow/glow effect for better visibility\n      ctx.shadowColor = 'rgba(34, 197, 94, 0.5)';\n      ctx.shadowBlur = 5;\n      POSE_CONNECTIONS.forEach(([i, j]) => {\n        const kp1 = landmarks[i];\n        const kp2 = landmarks[j];\n        if (kp1 && kp2 && kp1.visibility > 0.6 && kp2.visibility > 0.6) {\n          // เพิ่ม threshold\n          // MediaPipe coordinates are normalized (0-1), need to scale properly\n          const x1 = kp1.x * scaleX + offsetX;\n          const y1 = kp1.y * scaleY + offsetY;\n          const x2 = kp2.x * scaleX + offsetX;\n          const y2 = kp2.y * scaleY + offsetY;\n          ctx.beginPath();\n          ctx.moveTo(x1, y1);\n          ctx.lineTo(x2, y2);\n\n          // Different green shades for different body parts\n          if (i <= 10 || j <= 10) {\n            ctx.strokeStyle = '#15803d'; // Dark green for face/head\n          } else if (i >= 11 && i <= 16 || j >= 11 && j <= 16) {\n            ctx.strokeStyle = '#16a34a'; // Medium green for arms\n          } else {\n            ctx.strokeStyle = '#22c55e'; // Light green for body/legs\n          }\n          ctx.lineWidth = connectionWidth;\n          ctx.lineCap = 'round';\n          ctx.stroke();\n        }\n      });\n\n      // Reset shadow\n      ctx.shadowColor = 'transparent';\n      ctx.shadowBlur = 0;\n    }\n\n    // Draw keypoints with green theme\n    if (showKeypoints) {\n      landmarks.forEach((landmark, index) => {\n        if (landmark && landmark.visibility > 0.6) {\n          // เพิ่ม threshold สำหรับความแม่นยำ\n          // Ensure proper normalization - MediaPipe gives 0-1 coordinates\n          const normalizedX = Math.max(0, Math.min(1, landmark.x));\n          const normalizedY = Math.max(0, Math.min(1, landmark.y));\n          const x = normalizedX * scaleX + offsetX;\n          const y = normalizedY * scaleY + offsetY;\n\n          // Debug first few keypoints\n          if (index < 3) {\n            console.log(`Keypoint ${index}:`, {\n              original: {\n                x: landmark.x,\n                y: landmark.y\n              },\n              normalized: {\n                x: normalizedX,\n                y: normalizedY\n              },\n              scaled: {\n                x,\n                y\n              },\n              visibility: landmark.visibility\n            });\n          }\n\n          // Shadow/glow effect\n          ctx.shadowColor = 'rgba(34, 197, 94, 0.8)';\n          ctx.shadowBlur = 8;\n\n          // Main keypoint circle\n          ctx.beginPath();\n          ctx.arc(x, y, keypointSize, 0, 2 * Math.PI);\n\n          // Different green shades for different body parts\n          if (index <= 10) {\n            ctx.fillStyle = '#15803d'; // Dark green for face/head\n          } else if (index >= 11 && index <= 16) {\n            ctx.fillStyle = '#16a34a'; // Medium green for arms\n          } else if (index >= 17 && index <= 22) {\n            ctx.fillStyle = '#22c55e'; // Light green for hands\n          } else {\n            ctx.fillStyle = '#4ade80'; // Bright green for body/legs\n          }\n          ctx.fill();\n\n          // Reset shadow\n          ctx.shadowColor = 'transparent';\n          ctx.shadowBlur = 0;\n\n          // White border for better contrast\n          ctx.beginPath();\n          ctx.arc(x, y, keypointSize, 0, 2 * Math.PI);\n          ctx.strokeStyle = '#ffffff';\n          ctx.lineWidth = 2;\n          ctx.stroke();\n\n          // Inner bright dot for core joints\n          if ([11, 12, 23, 24, 13, 14, 15, 16, 25, 26, 27, 28].includes(index)) {\n            ctx.beginPath();\n            ctx.arc(x, y, 2, 0, 2 * Math.PI);\n            ctx.fillStyle = '#dcfce7'; // Very light green\n            ctx.fill();\n          }\n        }\n      });\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    style: {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      zIndex: 10\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 363,\n    columnNumber: 5\n  }, this);\n};\n_s(KeypointOverlay, \"m2C8+nABSeOQUESm7cHppPmlwFM=\");\n_c = KeypointOverlay;\nexport default KeypointOverlay;\nvar _c;\n$RefreshReg$(_c, \"KeypointOverlay\");","map":{"version":3,"names":["React","useRef","useEffect","useState","jsxDEV","_jsxDEV","KeypointOverlay","videoRef","isPlaying","onKeypointsDetected","_s","canvasRef","isInitialized","setIsInitialized","pose","setPose","POSE_CONNECTIONS","initializeMediaPipe","window","Pose","loadScript","poseInstance","locateFile","file","setOptions","modelComplexity","smoothLandmarks","enableSegmentation","smoothSegmentation","minDetectionConfidence","minTrackingConfidence","onResults","error","console","close","src","Promise","resolve","reject","document","querySelector","script","createElement","onload","onerror","head","appendChild","current","video","canvas","processFrame","paused","ended","rect","getBoundingClientRect","width","height","send","image","requestAnimationFrame","readyState","srcObject","onVideoReady","log","addEventListener","once","ctx","getContext","clearRect","currentLandmarks","previousLandmarks","alpha","map","landmark","index","prev","visibility","x","y","z","Math","max","results","poseLandmarks","length","_results$poseLandmark","landmarks","validLandmarks","filter","smoothed","setSmoothedLandmarks","setPreviousLandmarks","drawPoseMediaPipe","videoRect","videoWidth","videoHeight","canvasWidth","canvasHeight","scaleX","scaleY","offsetX","offsetY","style","objectFit","videoAspect","canvasAspect","showConnections","shadowColor","shadowBlur","forEach","i","j","kp1","kp2","x1","y1","x2","y2","beginPath","moveTo","lineTo","strokeStyle","lineWidth","connectionWidth","lineCap","stroke","showKeypoints","normalizedX","min","normalizedY","original","normalized","scaled","arc","keypointSize","PI","fillStyle","fill","includes","ref","position","top","left","pointerEvents","zIndex","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Fit/frontend/src/components/KeypointOverlay.js"],"sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\r\n\r\nconst KeypointOverlay = ({ videoRef, isPlaying, onKeypointsDetected }) => {\r\n  const canvasRef = useRef(null);\r\n  const [isInitialized, setIsInitialized] = useState(false);\r\n  const [pose, setPose] = useState(null);\r\n\r\n  // MediaPipe Pose connections (33 landmarks)\r\n  const POSE_CONNECTIONS = [\r\n    // Face\r\n    [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8],\r\n    // Arms\r\n    [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19],\r\n    [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20],\r\n    // Body\r\n    [11, 23], [12, 24], [23, 24],\r\n    // Legs\r\n    [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]\r\n  ];\r\n\r\n  useEffect(() => {\r\n    const initializeMediaPipe = async () => {\r\n      try {\r\n        // โหลด MediaPipe จาก CDN\r\n        if (!window.Pose) {\r\n          // โหลด scripts จาก CDN\r\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js');\r\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js');\r\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js');\r\n          await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js');\r\n        }\r\n\r\n        const poseInstance = new window.Pose({\r\n          locateFile: (file) => {\r\n            return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;\r\n          }\r\n        });\r\n\r\n        poseInstance.setOptions({\r\n          modelComplexity: 1,\r\n          smoothLandmarks: true,\r\n          enableSegmentation: false,\r\n          smoothSegmentation: true,\r\n          minDetectionConfidence: 0.5,\r\n          minTrackingConfidence: 0.5\r\n        });\r\n\r\n        poseInstance.onResults(onResults);\r\n        setPose(poseInstance);\r\n        setIsInitialized(true);\r\n      } catch (error) {\r\n        console.error('Failed to load MediaPipe:', error);\r\n      }\r\n    };\r\n\r\n    initializeMediaPipe();\r\n  }, []);\r\n\r\n  // Cleanup effect\r\n  useEffect(() => {\r\n    return () => {\r\n      if (pose) {\r\n        pose.close();\r\n      }\r\n    };\r\n  }, [pose]);\r\n\r\n  // Helper function to load scripts\r\n  const loadScript = (src) => {\r\n    return new Promise((resolve, reject) => {\r\n      if (document.querySelector(`script[src=\"${src}\"]`)) {\r\n        resolve();\r\n        return;\r\n      }\r\n      const script = document.createElement('script');\r\n      script.src = src;\r\n      script.onload = resolve;\r\n      script.onerror = reject;\r\n      document.head.appendChild(script);\r\n    });\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (!isInitialized || !pose || !videoRef?.current || !canvasRef.current) return;\r\n\r\n    const video = videoRef.current;\r\n    const canvas = canvasRef.current;\r\n    \r\n    const processFrame = async () => {\r\n      if (video.paused || video.ended || !isPlaying) return;\r\n      \r\n      try {\r\n        // Match canvas size to video element's display size exactly\r\n        const rect = video.getBoundingClientRect();\r\n        if (canvas.width !== rect.width || canvas.height !== rect.height) {\r\n          canvas.width = rect.width;\r\n          canvas.height = rect.height;\r\n        }\r\n        \r\n        // Send frame to MediaPipe\r\n        await pose.send({ image: video });\r\n      } catch (error) {\r\n        console.error('Pose detection error:', error);\r\n      }\r\n\r\n      if (isPlaying && !video.paused && !video.ended) {\r\n        requestAnimationFrame(processFrame);\r\n      }\r\n    };\r\n\r\n    if (isPlaying) {\r\n      if (video.readyState >= 2 || video.srcObject) {\r\n        // Video file ready or camera stream\r\n        processFrame();\r\n      } else {\r\n        // Wait for video to load\r\n        const onVideoReady = () => {\r\n          console.log('Video ready, starting pose detection');\r\n          processFrame();\r\n        };\r\n        \r\n        video.addEventListener('loadeddata', onVideoReady, { once: true });\r\n        video.addEventListener('loadedmetadata', onVideoReady, { once: true });\r\n      }\r\n    }\r\n\r\n    // Clean up canvas when not playing\r\n    if (!isPlaying) {\r\n      const ctx = canvas.getContext('2d');\r\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    }\r\n  }, [isPlaying, isInitialized, pose]);\r\n\r\n  // Temporal smoothing function\r\n  const smoothLandmarks = (currentLandmarks, previousLandmarks, alpha = 0.3) => {\r\n    if (!previousLandmarks) return currentLandmarks;\r\n    \r\n    return currentLandmarks.map((landmark, index) => {\r\n      const prev = previousLandmarks[index];\r\n      if (!prev || landmark.visibility < 0.5) return landmark;\r\n      \r\n      return {\r\n        x: alpha * landmark.x + (1 - alpha) * prev.x,\r\n        y: alpha * landmark.y + (1 - alpha) * prev.y,\r\n        z: alpha * landmark.z + (1 - alpha) * prev.z,\r\n        visibility: Math.max(landmark.visibility, prev.visibility * 0.9)\r\n      };\r\n    });\r\n  };\r\n\r\n  const onResults = (results) => {\r\n    const canvas = canvasRef.current;\r\n    const video = videoRef.current;\r\n    \r\n    if (!canvas || !video || !results.poseLandmarks || results.poseLandmarks.length === 0) {\r\n      console.log('Missing data for pose drawing:', {\r\n        canvas: !!canvas,\r\n        video: !!video,\r\n        landmarks: results.poseLandmarks?.length || 0\r\n      });\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Validate landmarks format\r\n      const validLandmarks = results.poseLandmarks.filter(landmark => \r\n        landmark && \r\n        typeof landmark.x === 'number' && \r\n        typeof landmark.y === 'number' && \r\n        typeof landmark.visibility === 'number' &&\r\n        landmark.x >= 0 && landmark.x <= 1 &&\r\n        landmark.y >= 0 && landmark.y <= 1\r\n      );\r\n\r\n      if (validLandmarks.length < 20) { // Need at least 20 valid landmarks\r\n        console.log('Not enough valid landmarks:', validLandmarks.length);\r\n        return;\r\n      }\r\n\r\n      // Apply temporal smoothing\r\n      const smoothed = smoothLandmarks(results.poseLandmarks, previousLandmarks);\r\n      setSmoothedLandmarks(smoothed);\r\n      setPreviousLandmarks(smoothed);\r\n      \r\n      drawPoseMediaPipe(smoothed, canvas, video);\r\n      \r\n      if (onKeypointsDetected) {\r\n        onKeypointsDetected(smoothed);\r\n      }\r\n    } catch (error) {\r\n      console.error('Drawing error:', error);\r\n    }\r\n  };\r\n\r\n  const drawPoseMediaPipe = (landmarks, canvas, video) => {\r\n    const ctx = canvas.getContext('2d');\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    // Make sure canvas matches video element size\r\n    const videoRect = video.getBoundingClientRect();\r\n    canvas.width = videoRect.width;\r\n    canvas.height = videoRect.height;\r\n\r\n    // Get video dimensions - handle camera stream case\r\n    let videoWidth = video.videoWidth;\r\n    let videoHeight = video.videoHeight;\r\n    \r\n    // For camera streams, dimensions might not be available immediately\r\n    if (!videoWidth || !videoHeight) {\r\n      // Wait for video metadata or use default camera resolution\r\n      if (video.srcObject) {\r\n        // Camera stream - use common webcam resolution\r\n        videoWidth = 640;\r\n        videoHeight = 480;\r\n      } else {\r\n        // Video file - wait for metadata\r\n        console.log('Video dimensions not available yet');\r\n        return;\r\n      }\r\n    }\r\n\r\n    const canvasWidth = canvas.width;\r\n    const canvasHeight = canvas.height;\r\n\r\n    console.log('Video dimensions:', videoWidth, 'x', videoHeight);\r\n    console.log('Canvas dimensions:', canvasWidth, 'x', canvasHeight);\r\n\r\n    // Calculate scale factors for proper normalization\r\n    // MediaPipe landmarks are normalized (0-1) relative to video dimensions\r\n    let scaleX, scaleY, offsetX = 0, offsetY = 0;\r\n\r\n    if (video.style.objectFit === 'contain' || video.style.objectFit === '') {\r\n      // For object-fit: contain, we need to calculate the actual video display area\r\n      const videoAspect = videoWidth / videoHeight;\r\n      const canvasAspect = canvasWidth / canvasHeight;\r\n\r\n      if (videoAspect > canvasAspect) {\r\n        // Video is wider - fit to width, letterbox top/bottom\r\n        scaleX = canvasWidth;\r\n        scaleY = canvasWidth / videoAspect;\r\n        offsetY = (canvasHeight - scaleY) / 2;\r\n      } else {\r\n        // Video is taller - fit to height, letterbox left/right  \r\n        scaleY = canvasHeight;\r\n        scaleX = canvasHeight * videoAspect;\r\n        offsetX = (canvasWidth - scaleX) / 2;\r\n      }\r\n    } else {\r\n      // For object-fit: cover or other modes, scale to full canvas\r\n      scaleX = canvasWidth;\r\n      scaleY = canvasHeight;\r\n    }\r\n\r\n    console.log('Scale factors:', scaleX, scaleY, 'Offsets:', offsetX, offsetY);\r\n\r\n    // Draw skeleton connections with better visibility\r\n    if (showConnections) {\r\n      // Shadow/glow effect for better visibility\r\n      ctx.shadowColor = 'rgba(34, 197, 94, 0.5)';\r\n      ctx.shadowBlur = 5;\r\n      \r\n      POSE_CONNECTIONS.forEach(([i, j]) => {\r\n        const kp1 = landmarks[i];\r\n        const kp2 = landmarks[j];\r\n        \r\n        if (kp1 && kp2 && kp1.visibility > 0.6 && kp2.visibility > 0.6) { // เพิ่ม threshold\r\n          // MediaPipe coordinates are normalized (0-1), need to scale properly\r\n          const x1 = kp1.x * scaleX + offsetX;\r\n          const y1 = kp1.y * scaleY + offsetY;\r\n          const x2 = kp2.x * scaleX + offsetX;\r\n          const y2 = kp2.y * scaleY + offsetY;\r\n          \r\n          ctx.beginPath();\r\n          ctx.moveTo(x1, y1);\r\n          ctx.lineTo(x2, y2);\r\n          \r\n          // Different green shades for different body parts\r\n          if (i <= 10 || j <= 10) {\r\n            ctx.strokeStyle = '#15803d'; // Dark green for face/head\r\n          } else if ((i >= 11 && i <= 16) || (j >= 11 && j <= 16)) {\r\n            ctx.strokeStyle = '#16a34a'; // Medium green for arms\r\n          } else {\r\n            ctx.strokeStyle = '#22c55e'; // Light green for body/legs\r\n          }\r\n          \r\n          ctx.lineWidth = connectionWidth;\r\n          ctx.lineCap = 'round';\r\n          ctx.stroke();\r\n        }\r\n      });\r\n      \r\n      // Reset shadow\r\n      ctx.shadowColor = 'transparent';\r\n      ctx.shadowBlur = 0;\r\n    }\r\n\r\n    // Draw keypoints with green theme\r\n    if (showKeypoints) {\r\n      landmarks.forEach((landmark, index) => {\r\n        if (landmark && landmark.visibility > 0.6) { // เพิ่ม threshold สำหรับความแม่นยำ\r\n          // Ensure proper normalization - MediaPipe gives 0-1 coordinates\r\n          const normalizedX = Math.max(0, Math.min(1, landmark.x));\r\n          const normalizedY = Math.max(0, Math.min(1, landmark.y));\r\n          \r\n          const x = normalizedX * scaleX + offsetX;\r\n          const y = normalizedY * scaleY + offsetY;\r\n          \r\n          // Debug first few keypoints\r\n          if (index < 3) {\r\n            console.log(`Keypoint ${index}:`, {\r\n              original: { x: landmark.x, y: landmark.y },\r\n              normalized: { x: normalizedX, y: normalizedY },\r\n              scaled: { x, y },\r\n              visibility: landmark.visibility\r\n            });\r\n          }\r\n          \r\n          // Shadow/glow effect\r\n          ctx.shadowColor = 'rgba(34, 197, 94, 0.8)';\r\n          ctx.shadowBlur = 8;\r\n          \r\n          // Main keypoint circle\r\n          ctx.beginPath();\r\n          ctx.arc(x, y, keypointSize, 0, 2 * Math.PI);\r\n          \r\n          // Different green shades for different body parts\r\n          if (index <= 10) {\r\n            ctx.fillStyle = '#15803d'; // Dark green for face/head\r\n          } else if (index >= 11 && index <= 16) {\r\n            ctx.fillStyle = '#16a34a'; // Medium green for arms\r\n          } else if (index >= 17 && index <= 22) {\r\n            ctx.fillStyle = '#22c55e'; // Light green for hands\r\n          } else {\r\n            ctx.fillStyle = '#4ade80'; // Bright green for body/legs\r\n          }\r\n          \r\n          ctx.fill();\r\n          \r\n          // Reset shadow\r\n          ctx.shadowColor = 'transparent';\r\n          ctx.shadowBlur = 0;\r\n          \r\n          // White border for better contrast\r\n          ctx.beginPath();\r\n          ctx.arc(x, y, keypointSize, 0, 2 * Math.PI);\r\n          ctx.strokeStyle = '#ffffff';\r\n          ctx.lineWidth = 2;\r\n          ctx.stroke();\r\n          \r\n          // Inner bright dot for core joints\r\n          if ([11, 12, 23, 24, 13, 14, 15, 16, 25, 26, 27, 28].includes(index)) {\r\n            ctx.beginPath();\r\n            ctx.arc(x, y, 2, 0, 2 * Math.PI);\r\n            ctx.fillStyle = '#dcfce7'; // Very light green\r\n            ctx.fill();\r\n          }\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  return (\r\n    <canvas\r\n      ref={canvasRef}\r\n      style={{\r\n        position: 'absolute',\r\n        top: 0,\r\n        left: 0,\r\n        width: '100%',\r\n        height: '100%',\r\n        pointerEvents: 'none',\r\n        zIndex: 10\r\n      }}\r\n    />\r\n  );\r\n};\r\n\r\nexport default KeypointOverlay;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}