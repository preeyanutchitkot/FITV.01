{"ast":null,"code":"export class MultiDirectionalPoseComparator {\n  constructor() {\n    this.MIN_VISIBILITY = 0.7;\n    this.IMPORTANT_JOINTS = ['nose', 'left_shoulder', 'right_shoulder', 'left_elbow', 'right_elbow', 'left_wrist', 'right_wrist', 'left_hip', 'right_hip', 'left_knee', 'right_knee', 'left_ankle', 'right_ankle'];\n  }\n\n  // คำนวนระยะห่างระหว่าง 2 จุด\n  calculateDistance(point1, point2) {\n    const dx = point1.x - point2.x;\n    const dy = point1.y - point2.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  // คำนวนมุมระหว่าง 3 จุด\n  calculateAngle(point1, point2, point3) {\n    const dx1 = point1.x - point2.x;\n    const dy1 = point1.y - point2.y;\n    const dx2 = point3.x - point2.x;\n    const dy2 = point3.y - point2.y;\n    const angle1 = Math.atan2(dy1, dx1);\n    const angle2 = Math.atan2(dy2, dx2);\n    let angle = Math.abs(angle1 - angle2);\n    if (angle > Math.PI) {\n      angle = 2 * Math.PI - angle;\n    }\n    return angle * (180 / Math.PI); // แปลงเป็นองศา\n  }\n\n  // เปรียบเทียบท่าด้วย Gemini AI\n  async analyzeWithGemini(trainerKeypoints, traineeKeypoints) {\n    try {\n      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${process.env.REACT_APP_GEMINI_API_KEY}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          contents: [{\n            parts: [{\n              text: `คุณเป็นผู้เชี่ยวชาญด้านการวิเคราะห์ท่าออกกำลังกาย วิเคราะห์ความถูกต้องของท่าโดยเปรียบเทียบ keypoints\n\nTrainer keypoints: ${JSON.stringify(trainerKeypoints)}\nTrainee keypoints: ${JSON.stringify(traineeKeypoints)}\n\nให้วิเคราะห์และตอบเป็น JSON format เท่านั้น:\n{\n  \"accuracy\": 0-100,\n  \"feedback\": \"คำแนะนำภาษาไทยสั้นๆ\",\n  \"recommendations\": [\"คำแนะนำ1\", \"คำแนะนำ2\"]\n}`\n            }]\n          }],\n          generationConfig: {\n            temperature: 0.3,\n            maxOutputTokens: 500\n          }\n        })\n      });\n      if (response.ok) {\n        const data = await response.json();\n        const content = data.candidates[0].content.parts[0].text;\n\n        // ลองแยก JSON จากข้อความ\n        const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n        if (jsonMatch) {\n          const aiResult = JSON.parse(jsonMatch[0]);\n          return aiResult;\n        }\n      }\n    } catch (error) {\n      console.log('Gemini API error:', error);\n    }\n    return null;\n  }\n\n  // เปรียบเทียบท่าด้วย OpenAI (backup)\n  async analyzeWithOpenAI(trainerKeypoints, traineeKeypoints) {\n    try {\n      const response = await fetch('https://api.openai.com/v1/chat/completions', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${process.env.REACT_APP_OPENAI_API_KEY}`\n        },\n        body: JSON.stringify({\n          model: \"gpt-3.5-turbo\",\n          messages: [{\n            role: \"system\",\n            content: \"คุณเป็นผู้เชี่ยวชาญด้านการวิเคราะห์ท่าออกกำลังกาย ให้คะแนนความถูกต้องของท่าโดยเปรียบเทียบ keypoints\"\n          }, {\n            role: \"user\",\n            content: `วิเคราะห์ท่าออกกำลังกาย:\n            Trainer keypoints: ${JSON.stringify(trainerKeypoints)}\n            Trainee keypoints: ${JSON.stringify(traineeKeypoints)}\n            \n            ให้คะแนนเป็น JSON format:\n            {\n              \"accuracy\": 0-100,\n              \"feedback\": \"คำแนะนำภาษาไทย\",\n              \"recommendations\": [\"คำแนะนำ1\", \"คำแนะนำ2\"]\n            }`\n          }],\n          max_tokens: 500,\n          temperature: 0.3\n        })\n      });\n      if (response.ok) {\n        const data = await response.json();\n        const aiResult = JSON.parse(data.choices[0].message.content);\n        return aiResult;\n      }\n    } catch (error) {\n      console.log('OpenAI API error:', error);\n    }\n    return null;\n  }\n\n  // เรียกใช้ AI โดยลองใช้ Gemini ก่อน แล้วค่อย fallback เป็น OpenAI\n  async analyzeWithAI(trainerKeypoints, traineeKeypoints) {\n    // ลอง Gemini ก่อน (ฟรี)\n    if (process.env.REACT_APP_GEMINI_API_KEY && process.env.REACT_APP_GEMINI_API_KEY !== 'ใส่_GEMINI_API_KEY_ตรงนี้') {\n      const geminiResult = await this.analyzeWithGemini(trainerKeypoints, traineeKeypoints);\n      if (geminiResult) {\n        return {\n          ...geminiResult,\n          aiProvider: 'Gemini'\n        };\n      }\n    }\n\n    // ถ้า Gemini ไม่ได้ ลอง OpenAI\n    if (process.env.REACT_APP_OPENAI_API_KEY && process.env.REACT_APP_OPENAI_API_KEY !== 'ใส่_OPENAI_API_KEY_ตรงนี้') {\n      const openaiResult = await this.analyzeWithOpenAI(trainerKeypoints, traineeKeypoints);\n      if (openaiResult) {\n        return {\n          ...openaiResult,\n          aiProvider: 'OpenAI'\n        };\n      }\n    }\n\n    // ไม่มี AI ไหนทำงาน\n    return null;\n  }\n\n  // คำนวนความแม่นยำแบบดั้งเดิม\n  calculateTraditionalAccuracy(trainerKeypoints, traineeKeypoints) {\n    let totalScore = 0;\n    let validJoints = 0;\n    const jointComparisons = {};\n    for (const joint of this.IMPORTANT_JOINTS) {\n      const trainerJoint = trainerKeypoints[joint];\n      const traineeJoint = traineeKeypoints[joint];\n      if (trainerJoint && traineeJoint && trainerJoint.visibility > this.MIN_VISIBILITY && traineeJoint.visibility > this.MIN_VISIBILITY) {\n        // คำนวนระยะห่างระหว่างจุด\n        const distance = this.calculateDistance(trainerJoint, traineeJoint);\n\n        // แปลงเป็นคะแนน (ยิ่งใกล้ยิ่งคะแนนสูง)\n        const maxDistance = 0.3; // ระยะห่างสูงสุดที่ยอมรับได้\n        const jointScore = Math.max(0, 100 - distance / maxDistance * 100);\n        totalScore += jointScore;\n        validJoints++;\n        jointComparisons[joint] = {\n          distance: distance,\n          score: Math.round(jointScore),\n          trainerPosition: {\n            x: trainerJoint.x,\n            y: trainerJoint.y\n          },\n          traineePosition: {\n            x: traineeJoint.x,\n            y: traineeJoint.y\n          }\n        };\n      }\n    }\n    return {\n      accuracy: validJoints > 0 ? Math.round(totalScore / validJoints) : 0,\n      jointComparisons: jointComparisons,\n      validJoints: validJoints\n    };\n  }\n  async compareMultiDirectional(trainerPose, traineePose) {\n    if (!trainerPose || !traineePose) {\n      return {\n        accuracy: 0,\n        confidence: 0,\n        feedback: \"กรุณาเริ่มทำท่าตามคลิป\",\n        jointComparisons: {},\n        trainerDirection: \"unknown\",\n        traineeDirection: \"unknown\",\n        bodyPartScores: {},\n        recommendations: []\n      };\n    }\n\n    // คำนวนแบบดั้งเดิมก่อน\n    const traditionalResult = this.calculateTraditionalAccuracy(trainerPose, traineePose);\n\n    // เรียก AI มาวิเคราะห์เพิ่มเติม\n    const aiResult = await this.analyzeWithAI(trainerPose, traineePose);\n\n    // รวมผลลัพธ์\n    let finalAccuracy = traditionalResult.accuracy;\n    let feedback = \"ปรับปรุงท่าให้ตรงมากขึ้น\";\n    let recommendations = [\"ปรับท่าให้ตรงกับคลิปมากขึ้น\"];\n    if (aiResult) {\n      // ใช้ค่าเฉลี่ยระหว่าง AI กับการคำนวนแบบดั้งเดิม\n      finalAccuracy = Math.round((traditionalResult.accuracy + aiResult.accuracy) / 2);\n      feedback = aiResult.feedback || feedback;\n      recommendations = aiResult.recommendations || recommendations;\n    }\n\n    // คำนวนคะแนนส่วนต่าง ๆ ของร่างกาย\n    const bodyPartScores = this.calculateBodyPartScores(traditionalResult.jointComparisons);\n    return {\n      accuracy: finalAccuracy,\n      confidence: traditionalResult.validJoints > 8 ? 90 : 70,\n      feedback: feedback,\n      jointComparisons: traditionalResult.jointComparisons,\n      trainerDirection: \"front\",\n      traineeDirection: \"front\",\n      bodyPartScores: bodyPartScores,\n      recommendations: recommendations,\n      aiAnalyzed: !!aiResult,\n      aiProvider: (aiResult === null || aiResult === void 0 ? void 0 : aiResult.aiProvider) || null,\n      traditionalScore: traditionalResult.accuracy,\n      aiScore: (aiResult === null || aiResult === void 0 ? void 0 : aiResult.accuracy) || null\n    };\n  }\n  calculateBodyPartScores(jointComparisons) {\n    const armJoints = ['left_shoulder', 'right_shoulder', 'left_elbow', 'right_elbow', 'left_wrist', 'right_wrist'];\n    const legJoints = ['left_hip', 'right_hip', 'left_knee', 'right_knee', 'left_ankle', 'right_ankle'];\n    const torsoJoints = ['nose', 'left_shoulder', 'right_shoulder', 'left_hip', 'right_hip'];\n    const calculatePartScore = joints => {\n      let total = 0;\n      let count = 0;\n      joints.forEach(joint => {\n        if (jointComparisons[joint]) {\n          total += jointComparisons[joint].score;\n          count++;\n        }\n      });\n      return count > 0 ? Math.round(total / count) : 0;\n    };\n    return {\n      arms: calculatePartScore(armJoints),\n      legs: calculatePartScore(legJoints),\n      torso: calculatePartScore(torsoJoints)\n    };\n  }\n}\n\n// Export instance สำหรับ import ที่มีอยู่\nexport const multiDirectionalPoseComparator = new MultiDirectionalPoseComparator();","map":{"version":3,"names":["MultiDirectionalPoseComparator","constructor","MIN_VISIBILITY","IMPORTANT_JOINTS","calculateDistance","point1","point2","dx","x","dy","y","Math","sqrt","calculateAngle","point3","dx1","dy1","dx2","dy2","angle1","atan2","angle2","angle","abs","PI","analyzeWithGemini","trainerKeypoints","traineeKeypoints","response","fetch","process","env","REACT_APP_GEMINI_API_KEY","method","headers","body","JSON","stringify","contents","parts","text","generationConfig","temperature","maxOutputTokens","ok","data","json","content","candidates","jsonMatch","match","aiResult","parse","error","console","log","analyzeWithOpenAI","REACT_APP_OPENAI_API_KEY","model","messages","role","max_tokens","choices","message","analyzeWithAI","geminiResult","aiProvider","openaiResult","calculateTraditionalAccuracy","totalScore","validJoints","jointComparisons","joint","trainerJoint","traineeJoint","visibility","distance","maxDistance","jointScore","max","score","round","trainerPosition","traineePosition","accuracy","compareMultiDirectional","trainerPose","traineePose","confidence","feedback","trainerDirection","traineeDirection","bodyPartScores","recommendations","traditionalResult","finalAccuracy","calculateBodyPartScores","aiAnalyzed","traditionalScore","aiScore","armJoints","legJoints","torsoJoints","calculatePartScore","joints","total","count","forEach","arms","legs","torso","multiDirectionalPoseComparator"],"sources":["E:/BackupFit/frontend/src/utils/MultiDirectionalPoseComparator.js"],"sourcesContent":["export class MultiDirectionalPoseComparator {\r\n  constructor() {\r\n    this.MIN_VISIBILITY = 0.7;\r\n    this.IMPORTANT_JOINTS = [\r\n      'nose', 'left_shoulder', 'right_shoulder', 'left_elbow', 'right_elbow',\r\n      'left_wrist', 'right_wrist', 'left_hip', 'right_hip', 'left_knee', \r\n      'right_knee', 'left_ankle', 'right_ankle'\r\n    ];\r\n  }\r\n\r\n  // คำนวนระยะห่างระหว่าง 2 จุด\r\n  calculateDistance(point1, point2) {\r\n    const dx = point1.x - point2.x;\r\n    const dy = point1.y - point2.y;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n  }\r\n\r\n  // คำนวนมุมระหว่าง 3 จุด\r\n  calculateAngle(point1, point2, point3) {\r\n    const dx1 = point1.x - point2.x;\r\n    const dy1 = point1.y - point2.y;\r\n    const dx2 = point3.x - point2.x;\r\n    const dy2 = point3.y - point2.y;\r\n    \r\n    const angle1 = Math.atan2(dy1, dx1);\r\n    const angle2 = Math.atan2(dy2, dx2);\r\n    let angle = Math.abs(angle1 - angle2);\r\n    \r\n    if (angle > Math.PI) {\r\n      angle = 2 * Math.PI - angle;\r\n    }\r\n    \r\n    return angle * (180 / Math.PI); // แปลงเป็นองศา\r\n  }\r\n\r\n  // เปรียบเทียบท่าด้วย Gemini AI\r\n  async analyzeWithGemini(trainerKeypoints, traineeKeypoints) {\r\n    try {\r\n      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${process.env.REACT_APP_GEMINI_API_KEY}`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          contents: [{\r\n            parts: [{\r\n              text: `คุณเป็นผู้เชี่ยวชาญด้านการวิเคราะห์ท่าออกกำลังกาย วิเคราะห์ความถูกต้องของท่าโดยเปรียบเทียบ keypoints\r\n\r\nTrainer keypoints: ${JSON.stringify(trainerKeypoints)}\r\nTrainee keypoints: ${JSON.stringify(traineeKeypoints)}\r\n\r\nให้วิเคราะห์และตอบเป็น JSON format เท่านั้น:\r\n{\r\n  \"accuracy\": 0-100,\r\n  \"feedback\": \"คำแนะนำภาษาไทยสั้นๆ\",\r\n  \"recommendations\": [\"คำแนะนำ1\", \"คำแนะนำ2\"]\r\n}`\r\n            }]\r\n          }],\r\n          generationConfig: {\r\n            temperature: 0.3,\r\n            maxOutputTokens: 500\r\n          }\r\n        })\r\n      });\r\n\r\n      if (response.ok) {\r\n        const data = await response.json();\r\n        const content = data.candidates[0].content.parts[0].text;\r\n        \r\n        // ลองแยก JSON จากข้อความ\r\n        const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\r\n        if (jsonMatch) {\r\n          const aiResult = JSON.parse(jsonMatch[0]);\r\n          return aiResult;\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.log('Gemini API error:', error);\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  // เปรียบเทียบท่าด้วย OpenAI (backup)\r\n  async analyzeWithOpenAI(trainerKeypoints, traineeKeypoints) {\r\n    try {\r\n      const response = await fetch('https://api.openai.com/v1/chat/completions', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Authorization': `Bearer ${process.env.REACT_APP_OPENAI_API_KEY}`\r\n        },\r\n        body: JSON.stringify({\r\n          model: \"gpt-3.5-turbo\",\r\n          messages: [{\r\n            role: \"system\",\r\n            content: \"คุณเป็นผู้เชี่ยวชาญด้านการวิเคราะห์ท่าออกกำลังกาย ให้คะแนนความถูกต้องของท่าโดยเปรียบเทียบ keypoints\"\r\n          }, {\r\n            role: \"user\",\r\n            content: `วิเคราะห์ท่าออกกำลังกาย:\r\n            Trainer keypoints: ${JSON.stringify(trainerKeypoints)}\r\n            Trainee keypoints: ${JSON.stringify(traineeKeypoints)}\r\n            \r\n            ให้คะแนนเป็น JSON format:\r\n            {\r\n              \"accuracy\": 0-100,\r\n              \"feedback\": \"คำแนะนำภาษาไทย\",\r\n              \"recommendations\": [\"คำแนะนำ1\", \"คำแนะนำ2\"]\r\n            }`\r\n          }],\r\n          max_tokens: 500,\r\n          temperature: 0.3\r\n        })\r\n      });\r\n\r\n      if (response.ok) {\r\n        const data = await response.json();\r\n        const aiResult = JSON.parse(data.choices[0].message.content);\r\n        return aiResult;\r\n      }\r\n    } catch (error) {\r\n      console.log('OpenAI API error:', error);\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  // เรียกใช้ AI โดยลองใช้ Gemini ก่อน แล้วค่อย fallback เป็น OpenAI\r\n  async analyzeWithAI(trainerKeypoints, traineeKeypoints) {\r\n    // ลอง Gemini ก่อน (ฟรี)\r\n    if (process.env.REACT_APP_GEMINI_API_KEY && process.env.REACT_APP_GEMINI_API_KEY !== 'ใส่_GEMINI_API_KEY_ตรงนี้') {\r\n      const geminiResult = await this.analyzeWithGemini(trainerKeypoints, traineeKeypoints);\r\n      if (geminiResult) {\r\n        return { ...geminiResult, aiProvider: 'Gemini' };\r\n      }\r\n    }\r\n\r\n    // ถ้า Gemini ไม่ได้ ลอง OpenAI\r\n    if (process.env.REACT_APP_OPENAI_API_KEY && process.env.REACT_APP_OPENAI_API_KEY !== 'ใส่_OPENAI_API_KEY_ตรงนี้') {\r\n      const openaiResult = await this.analyzeWithOpenAI(trainerKeypoints, traineeKeypoints);\r\n      if (openaiResult) {\r\n        return { ...openaiResult, aiProvider: 'OpenAI' };\r\n      }\r\n    }\r\n\r\n    // ไม่มี AI ไหนทำงาน\r\n    return null;\r\n  }\r\n\r\n  // คำนวนความแม่นยำแบบดั้งเดิม\r\n  calculateTraditionalAccuracy(trainerKeypoints, traineeKeypoints) {\r\n    let totalScore = 0;\r\n    let validJoints = 0;\r\n    const jointComparisons = {};\r\n\r\n    for (const joint of this.IMPORTANT_JOINTS) {\r\n      const trainerJoint = trainerKeypoints[joint];\r\n      const traineeJoint = traineeKeypoints[joint];\r\n\r\n      if (trainerJoint && traineeJoint && \r\n          trainerJoint.visibility > this.MIN_VISIBILITY && \r\n          traineeJoint.visibility > this.MIN_VISIBILITY) {\r\n        \r\n        // คำนวนระยะห่างระหว่างจุด\r\n        const distance = this.calculateDistance(trainerJoint, traineeJoint);\r\n        \r\n        // แปลงเป็นคะแนน (ยิ่งใกล้ยิ่งคะแนนสูง)\r\n        const maxDistance = 0.3; // ระยะห่างสูงสุดที่ยอมรับได้\r\n        const jointScore = Math.max(0, 100 - (distance / maxDistance) * 100);\r\n        \r\n        totalScore += jointScore;\r\n        validJoints++;\r\n        \r\n        jointComparisons[joint] = {\r\n          distance: distance,\r\n          score: Math.round(jointScore),\r\n          trainerPosition: { x: trainerJoint.x, y: trainerJoint.y },\r\n          traineePosition: { x: traineeJoint.x, y: traineeJoint.y }\r\n        };\r\n      }\r\n    }\r\n\r\n    return {\r\n      accuracy: validJoints > 0 ? Math.round(totalScore / validJoints) : 0,\r\n      jointComparisons: jointComparisons,\r\n      validJoints: validJoints\r\n    };\r\n  }\r\n\r\n  async compareMultiDirectional(trainerPose, traineePose) {\r\n    if (!trainerPose || !traineePose) {\r\n      return { \r\n        accuracy: 0,\r\n        confidence: 0,\r\n        feedback: \"กรุณาเริ่มทำท่าตามคลิป\",\r\n        jointComparisons: {},\r\n        trainerDirection: \"unknown\",\r\n        traineeDirection: \"unknown\",\r\n        bodyPartScores: {},\r\n        recommendations: []\r\n      };\r\n    }\r\n\r\n    // คำนวนแบบดั้งเดิมก่อน\r\n    const traditionalResult = this.calculateTraditionalAccuracy(trainerPose, traineePose);\r\n    \r\n    // เรียก AI มาวิเคราะห์เพิ่มเติม\r\n    const aiResult = await this.analyzeWithAI(trainerPose, traineePose);\r\n    \r\n    // รวมผลลัพธ์\r\n    let finalAccuracy = traditionalResult.accuracy;\r\n    let feedback = \"ปรับปรุงท่าให้ตรงมากขึ้น\";\r\n    let recommendations = [\"ปรับท่าให้ตรงกับคลิปมากขึ้น\"];\r\n\r\n    if (aiResult) {\r\n      // ใช้ค่าเฉลี่ยระหว่าง AI กับการคำนวนแบบดั้งเดิม\r\n      finalAccuracy = Math.round((traditionalResult.accuracy + aiResult.accuracy) / 2);\r\n      feedback = aiResult.feedback || feedback;\r\n      recommendations = aiResult.recommendations || recommendations;\r\n    }\r\n\r\n    // คำนวนคะแนนส่วนต่าง ๆ ของร่างกาย\r\n    const bodyPartScores = this.calculateBodyPartScores(traditionalResult.jointComparisons);\r\n\r\n    return { \r\n      accuracy: finalAccuracy,\r\n      confidence: traditionalResult.validJoints > 8 ? 90 : 70,\r\n      feedback: feedback,\r\n      jointComparisons: traditionalResult.jointComparisons,\r\n      trainerDirection: \"front\",\r\n      traineeDirection: \"front\",\r\n      bodyPartScores: bodyPartScores,\r\n      recommendations: recommendations,\r\n      aiAnalyzed: !!aiResult,\r\n      aiProvider: aiResult?.aiProvider || null,\r\n      traditionalScore: traditionalResult.accuracy,\r\n      aiScore: aiResult?.accuracy || null\r\n    };\r\n  }\r\n\r\n  calculateBodyPartScores(jointComparisons) {\r\n    const armJoints = ['left_shoulder', 'right_shoulder', 'left_elbow', 'right_elbow', 'left_wrist', 'right_wrist'];\r\n    const legJoints = ['left_hip', 'right_hip', 'left_knee', 'right_knee', 'left_ankle', 'right_ankle'];\r\n    const torsoJoints = ['nose', 'left_shoulder', 'right_shoulder', 'left_hip', 'right_hip'];\r\n\r\n    const calculatePartScore = (joints) => {\r\n      let total = 0;\r\n      let count = 0;\r\n      joints.forEach(joint => {\r\n        if (jointComparisons[joint]) {\r\n          total += jointComparisons[joint].score;\r\n          count++;\r\n        }\r\n      });\r\n      return count > 0 ? Math.round(total / count) : 0;\r\n    };\r\n\r\n    return {\r\n      arms: calculatePartScore(armJoints),\r\n      legs: calculatePartScore(legJoints),\r\n      torso: calculatePartScore(torsoJoints)\r\n    };\r\n  }\r\n}\r\n\r\n// Export instance สำหรับ import ที่มีอยู่\r\nexport const multiDirectionalPoseComparator = new MultiDirectionalPoseComparator();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}